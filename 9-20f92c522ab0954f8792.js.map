{"version":3,"sources":["webpack:///../src/perform-visitor.ts","webpack:///./node_modules/core-js/modules/es6.number.is-nan.js","webpack:////home/runner/work/effectsjs/effectsjs/babel/packages/babel-parser/lib/index.js","webpack:///../src/traverse-utilities.ts","webpack:///../src/effects-directive-visitor.ts","webpack:///./node_modules/core-js/modules/es6.string.from-code-point.js","webpack:///../src/to-generator-visitor.ts","webpack:///../src/recall-visitor.ts","webpack:///../src/plugin.ts","webpack:///../src/handler-method-visitor.ts","webpack:///./node_modules/core-js/modules/es6.string.code-point-at.js"],"names":["traverse_utilities_1","$export","S","isNaN","number","Object","defineProperty","exports","value","TokenType","label","conf","this","keyword","beforeExpr","startsExpr","rightAssociative","isLoop","isAssign","prefix","postfix","binop","updateContext","keywords","Map","createKeyword","name","options","token","set","createBinop","types","num","bigint","regexp","string","eof","bracketL","bracketR","braceL","braceBarL","braceR","braceBarR","parenL","parenR","comma","semi","colon","doubleColon","dot","question","questionDot","arrow","template","ellipsis","backQuote","dollarBraceL","at","hash","interpreterDirective","eq","assign","incDec","bang","tilde","pipeline","nullishCoalescing","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","exponent","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","perform","handle","recall","functionFlags","isAsync","isGenerator","isSimpleProperty","node","type","kind","method","lineBreak","lineBreakG","RegExp","source","isNewLine","code","skipWhiteSpace","isWhitespace","TokContext","isExpr","preserveSpace","override","types$1","braceStatement","braceExpression","templateQuasi","parenStatement","parenExpression","p","readTmplToken","functionExpression","functionStatement","state","context","length","out","pop","curContext","exprAllowed","prevType","allowed","scope","inGenerator","isIterator","push","braceIsBlock","statementParens","test","input","slice","lastTokEnd","start","b_stat","reservedWords","reservedWordsStrictSet","Set","reservedWordsStrictBindSet","isReservedWord","word","inModule","isStrictReservedWord","has","isStrictBindOnlyReservedWord","isStrictBindReservedWord","keywordRelationalOperator","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","pos","i","isIdentifierStart","String","fromCharCode","isIdentifierChar","reservedTypes","hasTypeImportKind","importKind","isMaybeDefaultImport","exportSuggestions","const","let","interface","FLOW_PRAGMA_REGEX","entities","quot","amp","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","HEX_NUMBER","DECIMAL_NUMBER","isFragment","object","getQualifiedJSXName","namespace","property","Error","j_oTag","j_cTag","j_expr","jsxName","jsxText","jsxTagStart","jsxTagEnd","Scope","flags","var","lexical","functions","ScopeHandler","raise","scopeStack","undefinedExports","createScope","enter","exit","treatFunctionsAsVarInScope","declareName","bindingType","currentScope","checkRedeclarationInScope","maybeExportDefined","SCOPE_PROGRAM","delete","isRedeclaredInScope","indexOf","checkLocalExport","id","currentVarScope","currentThisScope","TypeScriptScope","args","enums","constEnums","classes","exportOnlyBindings","TypeScriptScopeHandler","arguments","isConst","wasConst","nonNull","x","assert","placeholder","hasPlugin","plugins","some","plugin","Array","isArray","getPluginOption","option","find","PIPELINE_PROPOSALS","mixinPlugins","estree","superClass","estreeParseRegExpLiteral","pattern","regex","e","estreeParseLiteral","estreeParseBigIntLiteral","bigInt","BigInt","parseLiteral","directiveToStmt","directive","directiveLiteral","stmt","startNodeAt","loc","expression","raw","extra","finishNodeAt","end","initFunction","checkDeclaration","checkGetterSetterParams","paramCount","params","checkLVal","expr","checkClashes","contextDescription","disallowLetBinding","properties","forEach","checkDuplicatedProto","protoRef","computed","shorthand","key","used","isStrictBody","body","_i","_node$body$body","isValidDirective","parenthesized","stmtToDirective","parseBlockBody","allowDirectives","topLevel","directiveStatements","directives","map","d","concat","pushClassMethod","classBody","isConstructor","allowsDirectSuper","parseMethod","typeParameters","parseExprAtom","refShorthandDefaultPos","startPos","startLoc","parseFunctionBody","allowExpression","isMethod","allowDirectSuper","inClassScope","funcNode","startNode","finishNode","parseObjectMethod","isPattern","containsEsc","parseObjectProperty","toAssignable","isBinding","toAssignableObjectExpressionProp","isLast","finishCallExpression","optional","callee","toReferencedListDeep","exprList","isParenthesizedExpr","jsx","jsxReadToken","chunkStart","ch","charCodeAt","finishToken","getTokenFromCode","jsxReadEntity","jsxReadNewLine","normalizeCRLF","curLine","lineStart","jsxReadString","quote","entity","str","count","substr","fromCodePoint","parseInt","jsxReadWord","jsxParseIdentifier","match","unexpected","next","jsxParseNamespacedName","eat","jsxParseElementName","newNode","jsxParseAttributeValue","jsxParseExpressionContainer","jsxParseEmptyExpression","lastTokEndLoc","jsxParseSpreadChild","parseExpression","expect","jsxParseAttribute","argument","parseMaybeAssign","jsxParseOpeningElementAt","jsxParseOpeningElementAfterName","attributes","selfClosing","jsxParseClosingElementAt","jsxParseElementAt","children","openingElement","closingElement","contents","openingFragment","closingFragment","isRelational","jsxParseElement","refShortHandDefaultPos","inPropertyName","flow","flowPragma","undefined","shouldParseTypes","shouldParseEnums","val","addComment","comment","matches","exec","flowParseTypeInitialiser","tok","oldInType","inType","flowParseType","flowParsePredicate","moduloLoc","moduloPos","checksLoc","expectContextual","line","column","flowParseTypeAndPredicateInitialiser","predicate","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","parseIdentifier","typeNode","typeContainer","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","rest","returnType","typeAnnotation","resetEndLocation","semicolon","flowParseDeclare","insideModule","flowParseDeclareVariable","eatContextual","flowParseDeclareModuleExports","lastTokStart","flowParseDeclareModule","isContextual","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","flowParseTypeAnnotatableIdentifier","BIND_KIND_VALUE","bodyNode","parseImport","hasModuleExport","errorMessage","bodyElement","declaration","isEsModuleType","default","isLet","suggestion","parseExport","exportKind","flowParseTypeAnnotation","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","extends","implements","mixins","flowParseInterfaceExtends","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","checkNotUnderscore","checkReservedType","liberal","right","declare","supertype","impltype","flowParseTypeParameter","requireDefault","nodeStart","variance","flowParseVariance","ident","bound","defaultRequired","typeParameter","expectRelational","oldNoAnonFunctionType","noAnonFunctionType","flowParseTypeParameterInstantiationCallOrNew","flowParseTypeOrImplicitInstantiation","flowParseInterfaceType","flowParseObjectPropertyKey","flowParseObjectTypeIndexer","isStatic","static","lookahead","flowParseObjectTypeInternalSlot","flowParseObjectTypeMethodish","flowParseFunctionTypeParam","flowParseObjectTypeCallProperty","valueNode","endDelim","exact","callProperties","indexers","internalSlots","inexact","protoStart","inexactStart","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","proto","flowCheckGetterSetterParams","node2","qualification","flowParseGenericType","flowParseTypeofType","flowParsePrimaryType","flowParseTupleType","lh","reinterpretTypeAsFunctionTypeParam","flowIdentToTypeAnnotation","isGroupedType","createIdentifier","flowParsePostfixType","canInsertSemicolon","elementType","flowParsePrefixType","flowParseAnonFunctionWithoutParens","param","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","typeCastToParameter","allowExpressionBody","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","parseStatement","strict","flowParseEnumDeclaration","parseExpressionStatement","shouldParseExportDeclaration","isExportDefaultSpecifier","parseExportDefaultExpression","parseConditional","noIn","refNeedsArrowPos","result","tryParse","error","failState","clone","originalNoArrowAt","noArrowAt","tryParseConditionalConsequent","consequent","failed","getArrowLikeExpressions","valid","invalid","alternate","noArrowParamsConversionAt","disallowInvalid","stack","arrows","finishArrowValidation","list","list1","list2","partition","every","isAssignable","_node$extra","toAssignableList","trailingComma","checkParams","parse","parseParenItem","typeCastNode","assertModuleNodeAllowed","decl","parseExportDeclaration","declarationNode","specifiers","parseExportSpecifiers","parseExportFrom","eatExportStar","maybeParseExportNamespaceSpecifier","hasNamespace","parseClassId","isStatement","optionalId","finishOp","current","isIteratorStart","readWord","last","elements","element","operator","trailingCommaPos","toReferencedList","parseClassProperty","parseClassPrivateProperty","isClassMethod","isClassProperty","isNonstaticConstructor","pushClassPrivateMethod","parseClassSuper","superTypeParameters","implemented","parsePropertyName","parseObjPropValue","parseAssignableListItemTypes","parseMaybeDefault","left","shouldParseDefaultImport","parseImportSpecifierLocal","specifier","local","maybeParseDefaultImportSpecifier","parseImportSpecifier","firstIdentLoc","firstIdent","specifierTypeKind","isLookaheadContextual","as_ident","imported","__clone","nodeIsTypeImport","specifierIsTypeImport","checkReservedWord","parseFunctionParams","allowModifiers","parseVarId","parseAsyncArrowFromCallExpression","call","shouldParseAsyncArrow","afterLeftParse","arrowExpression","resetStartLocationFromNode","thrown","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","parseParenAndDistinguishExpression","canBeArrow","parseSubscripts","base","noCalls","parseCallExpressionArguments","abort","parseAsyncArrowWithTypeParameters","aborted","parseSubscript","subscriptState","isLookaheadRelational","expectPlugin","optionalChainMember","stop","typeArguments","parseNewArguments","targs","parseArrowExpression","readToken_mult_modulo","hasFlowComment","nextToken","readToken_pipe_amp","parseTopLevel","file","program","fileNode","skipBlockComment","skipFlowComment","hasFlowCommentCompletion","shiftToFirstNonWhiteSpace","includes","ch2","ch3","flowEnumErrorBooleanMemberNotInitialized","enumName","memberName","flowEnumErrorInvalidMemberName","toUpperCase","flowEnumErrorDuplicateMemberName","flowEnumErrorInconsistentMemberValues","flowEnumErrorInvalidExplicitType","suppliedType","message","flowEnumErrorInvalidMemberInitializer","explicitType","flowEnumErrorNumberMemberNotInitialized","flowEnumErrorStringMemberInconsistentlyInitailized","flowEnumMemberInit","endOfInit","literal","parseBooleanLiteral","flowEnumMemberRaw","init","flowEnumCheckExplicitTypeMismatch","expectedType","flowEnumMembers","seenNames","members","booleanMembers","numberMembers","stringMembers","defaultedMembers","memberNode","add","flowEnumStringMembers","initializedMembers","member","_i2","flowEnumParseExplicitType","flowEnumBody","nameLoc","boolsLen","numsLen","strsLen","defaultedLen","_i3","_members$defaultedMem","_i4","_members$defaultedMem2","typescript","getScopeHandler","tsIsIdentifier","tsNextTokenCanFollowModifier","hasPrecedingLineBreak","tsParseModifier","allowedModifiers","modifier","tsTryParse","bind","tsParseModifiers","modifiers","create","hasOwnProperty","tsIsListTerminator","tsParseList","parseElement","tsParseDelimitedList","tsParseDelimitedListWorker","expectSuccess","tsParseBracketedList","bracket","skipFirstToken","tsParseImportType","qualifier","tsParseEntityName","tsParseTypeArguments","allowReservedWords","startNodeAtNode","tsParseTypeReference","typeName","tsParseThisTypePredicate","lhs","parameterName","tsParseTypeAnnotation","tsParseThisTypeNode","tsParseTypeQuery","exprName","tsParseTypeParameter","parseIdentifierName","constraint","tsEatThenParseType","tsTryParseTypeParameters","tsParseTypeParameters","tsTryNextParseConstantContext","tsFillSignature","returnToken","signature","returnTokenRequired","parameters","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","parseBindingList","tsParseTypeMemberSemicolon","tsParseSignatureMember","tsIsUnambiguouslyIndexSignature","tsTryParseIndexSignature","tsLookAhead","tsTryParseTypeAnnotation","tsParsePropertyOrMethodSignature","readonly","nodeAny","tsParseTypeMember","idx","tsParseTypeLiteral","tsParseObjectTypeMembers","tsIsStartOfMappedType","tsParseMappedTypeParameter","tsExpectThenParseType","tsParseMappedType","tsTryParseType","tsParseTupleType","elementTypes","tsParseTupleElementType","seenOptionalElement","elementNode","restNode","tsParseType","lookaheadCharCode","raiseRestNotLast","optionalTypeNode","tsParseParenthesizedType","tsParseFunctionOrConstructorType","tsParseLiteralTypeNode","tsParseTemplateLiteralType","templateNode","parseTemplate","expressions","tsParseThisTypeOrThisTypePredicate","thisKeyword","tsParseNonArrayType","keywordTypeFromName","parseMaybeUnary","tsParseArrayTypeOrHigher","objectType","indexType","tsParseTypeOperator","tsParseTypeOperatorOrHigher","tsCheckTypeAnnotationForReadOnly","tsParseInferType","kw","tsParseUnionOrIntersectionType","parseConstituentType","tsParseIntersectionTypeOrHigher","tsParseUnionTypeOrHigher","tsIsStartOfFunctionType","tsIsUnambiguouslyStartOfFunctionType","tsSkipParameterStart","braceStackCounter","tsInType","t","asserts","tsParseTypePredicateAsserts","thisTypePredicate","typePredicateVariable","tsParseTypePredicatePrefix","tsTryParseTypeOrTypePredicateAnnotation","eatColon","tsParseNonConditionalType","checkType","extendsType","trueType","falseType","tsParseTypeAssertion","tsNextThenParseType","tsParseHeritageClause","descriptor","originalStart","delimitedList","tsParseExpressionWithTypeArguments","tsParseInterfaceDeclaration","tsParseTypeAliasDeclaration","tsInNoContext","cb","oldContext","tsDoThenParseType","tsParseEnumMember","initializer","tsParseEnumDeclaration","BIND_TS_ENUM","tsParseModuleBlock","parseBlockOrModuleBlockBody","tsParseModuleOrNamespaceDeclaration","nested","inner","tsParseAmbientExternalModuleDeclaration","global","tsParseImportEqualsDeclaration","isExport","moduleReference","tsParseModuleReference","tsIsExternalModuleReference","tsParseExternalModuleReference","f","res","tsTryParseAndCatch","tsTryParseDeclare","nany","isLineTerminator","starttype","parseFunctionStatement","parseClass","parseVarStatement","tsParseDeclaration","tsTryParseExportDeclaration","tsParseExpressionStatement","mod","tsCheckLineTerminatorAndMatch","cls","abstract","tokenType","tsTryParseGenericAsyncArrowFunction","tsIsDeclarationStart","parseAssignableListItem","decorators","accessibility","parseAccessModifier","elt","pp","parameter","bodilessType","registerFunctionStatementId","nonNullExpression","atPossibleAsync","asyncArrowFn","parseTaggedTemplateExpression","parseExprOp","leftStartPos","leftStartLoc","minPrec","checkKeywords","checkDuplicateExports","isAbstractClass","parseStatementContent","ahead","parseClassMember","constructorAllowsSuper","parseClassMemberWithIsStatic","parsePostMemberNameModifiers","methodOrProp","isDeclare","resetStartLocation","parseClassPropertyAnnotation","definite","equal","typeCast","parseBindingAtom","parseMaybeDecoratorArguments","isInParens","_exprListItem","canHaveLeadingDecorator","getGetterSetterExpectedParamCount","baseCount","firstParam","v8intrinsic","parseV8Intrinsic","v8IntrinsicStart","identifier","placeholders","parsePlaceholder","expectedNode","assertNoSpace","finishPlaceholder","isFinished","verifyBreakContinue","parseBlock","parseFunctionId","takeDecorators","parseClassBody","exported","maybeParseExportDefaultSpecifier","checkExport","filter","hasStarImport","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","parseImportSource","mixinPluginNames","keys","defaultOptions","sourceType","sourceFilename","startLine","allowAwaitOutsideFunction","allowReturnOutsideFunction","allowImportExportEverywhere","allowSuperOutsideMethod","allowUndeclaredExports","strictMode","ranges","tokens","createParenthesizedExpressions","errorRecovery","Position","col","SourceLocation","LocationParser","getLocationForPosition","lastTokStartLoc","endLoc","offset","lastIndex","index","getLineInfo","missingPluginNames","err","SyntaxError","missingPlugin","isLookahead","errors","filename","trailingComments","leadingComments","adjustCommentsAfterTrailingComma","takeAllComments","lastElement","j","commentPreviousNode","splice","newTrailingComments","leadingComment","processComment","firstChild","lastChild","commentStack","lastInStack","innerComments","sawUnambiguousESM","ambiguousScriptDifferentAst","get","State","potentialArrowAt","inParameters","maybeInArrowParameters","inPipeline","inClassProperty","topicContext","maxNumOfResolvableTopics","maxTopicIndex","soloAwait","inFSharpPipelineDirectBody","classLevel","labels","decoratorStack","yieldPos","awaitPos","comments","containsOctal","octalPosition","exportedIdentifiers","invalidTemplateEscapePosition","curPosition","skipArrays","_isDigit","VALID_REGEX_FLAGS","forbiddenNumericSeparatorSiblings","decBinOct","hex","allowedNumericSeparatorSiblings","oct","bin","dec","Token","UtilParser","addExtra","op","nextTokenStart","charAt","afterNext","eatRelational","isUnparsedContextual","nameStart","nameEnd","messageOrType","expectOnePlugin","names","n","join","checkYieldAwaitInDefaultParams","strictDirective","fn","oldState","abortSignal","checkKeywordEscapes","old","curr","thisTokEnd","setStrict","lastIndexOf","skipSpace","codePointAt","pushComment","block","text","skipLineComment","startSkip","loop","readToken_numberSign","readToken_interpreter","nextPos","readToken_dot","readNumber","readToken_slash","readRegexp","width","readToken_caret","readToken_plus_min","readToken_lt_gt","size","readToken_eq_excl","readToken_question","next2","readRadixNumber","readString","escaped","inClass","content","mods","char","charCode","readInt","radix","len","forceLen","allowNumSeparator","forbiddenSiblings","allowedSiblings","total","Infinity","prev","Number","isBigInt","replace","startsWithDot","isFloat","isNonOctalDecimalInt","octal","underscorePos","parseFloat","readCodePoint","throwOnInvalid","codePos","readHexChar","readEscapedChar","containsInvalid","inTemplate","octalStr","readWord1","escStart","identifierCheck","esc","parent","update","Node","parser","range","loopLabel","switchLabel","Parser","opts","_Object$keys","getOptions","pluginMap","pluginsMap","interpreter","parseInterpreterDirective","_Array$from","from","nextCh","parseDecorators","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseHandleMatcher","parseWhileStatement","parseWithStatement","parseEmptyStatement","nextTokenCharCode","isAsyncFunction","maybeName","parseLabeledStatement","allowExport","currentContextDecorators","decorator","parseDecorator","parseExprSubscripts","isBreak","lab","parseHeaderExpression","withTopicForbiddingContext","awaitAt","isAwaitAllowed","parseFor","parseVar","declarations","parseForIn","description","declarationPosition","parseFunction","inFunction","discriminant","cur","sawDefault","cases","isCase","handler","clause","simple","parseCatchHandleClause","finalizer","effectMatcher","defaultMatcher","parseHandleClause","_this$state$labels","statementStart","createNewLexicalScope","oldStrict","parsedNonDirective","isForIn","await","isFor","isTypescript","statement","isHangingStatement","requireId","generator","oldMaybeInArrowParameters","oldInClassProperty","oldYieldPos","oldAwaitPos","async","oldInParameters","treatFunctionsAsVar","hadConstructor","publicMethod","privateMethod","publicProp","privateProp","publicMember","parseClassPropertyName","isPrivate","isSimple","maybeQuestionTokenStart","pushClassPrivateProperty","pushClassProperty","SCOPE_CLASS","hasDefault","parseAfterDefault","hasStar","parseAfterNamespace","isFromRequired","hasDeclaration","hasSpecifiers","maybeParseExportNamedSpecifiers","maybeParseExportDeclaration","FUNC_STATEMENT","checkNames","isDefault","isFrom","_node$specifiers","_node$declaration$dec","_i5","_node$properties","_i6","_node$elements","elem","nodes","first","parseNext","getExpression","failOnShorthandAssign","parseYield","parseMaybeConditional","parseExprOps","prec","checkPipelineAtInfixOperator","inAsync","parseExprOpRightExpr","withTopicPermittingContext","parseSmartPipelineBody","parseExprOpBaseRightExpr","withSoloAwaitPermittingContext","parseFSharpPipelineBody","parseAwait","arg","maybeAsyncArrow","parseNoCallExpr","parseMaybePrivateName","tag","quasi","importArg","close","possibleAsyncArrow","dynamicImport","allowPlaceholder","nodeForExtra","innerParenStart","elts","oldInFSharpPipelineDirectBody","parseExprListItem","_call$extra","allowSuper","parseImportMetaProperty","oldLabels","parseExprList","ret","parseObj","parseFunctionExpression","parseNew","primaryTopicReferenceIsAllowedInCurrentTopicContext","registerTopicReference","meta","parseMetaProperty","propertyName","spreadStart","optionalCommaStart","innerStartPos","innerStartLoc","spreadNodeStartPos","spreadNodeStartLoc","parseRestBinding","checkCommaAfterRest","innerEndPos","innerEndLoc","arrowNode","parenStart","metaProp","inNonArrowFunction","parseTemplateElement","isTagged","cooked","tail","curElt","quasis","propHash","parseObjectMember","isAsyncProp","parseSpread","isGetterOrSetterMethod","oldInPropertyName","_node$body$directives","isExpression","useStrict","nonSimple","isSimpleParamList","errorPos","strictModeChanged","nameHash","allowEmpty","identifierName","isKeyword","delegate","childExpression","pipelineStyle","checkSmartPipelineBodyStyle","checkSmartPipelineBodyEarlyErrors","parseSmartPipelineBodyInStyle","topicReferenceWasUsedInCurrentTopicContext","isSimpleReference","callback","outerContextTopicState","outerContextSoloAwaitState","_node$extra3","unwrapParenthesizedExpression","_node$extra2","checkToRestConversion","raiseTrailingCommaAfterRest","closeCharCode","_expr$properties","_expr$elements","locationNode","getParser","decoratorsBeforeExport","validatePlugins","pluginsFromOptions","pluginList","parserClassCache","getParserClass","ast","_unused","moduleError","_unused2","tokTypes","path","toAbsoluteIndex","$fromCodePoint","F","aLen","RangeError","$at","P"],"mappings":"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I,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,KAAM,KAAM,IAAK,KAAM,IAAK,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,KAAM,EAAG,IAAK,KAAM,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,KAAM,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,KAAM,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,KAAM,GAAI,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,KAAM,IAAK,GAAI,GAAI,EAAG,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,KAAM,MAAO,GAAI,KAAM,GAAI,IAAK,EAAG,KAAM,GAAI,KAAM,KAAM,KACjrDC,EAAwB,CAAC,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,MAAO,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,MAAO,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,KAAM,GAAI,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG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","file":"9-20f92c522ab0954f8792.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar traverse_utilities_1 = require(\"./traverse-utilities\");\n/**\n * Visit recall statements and convert them to an interpreted stack frame call.\n */\nexports.performVisitor = {\n    UnaryExpression: function (path, _a) {\n        var types = _a.types;\n        // TODO [minor] ignore required because types do not recognize the operator as valid. Fix that.\n        // @ts-ignore\n        if (path.node.operator === \"perform\") {\n            traverse_utilities_1.fixupParentGenerator(path, types);\n            path.replaceWith(types.yieldExpression(types.callExpression(types.identifier(\"performEffect\"), [\n                path.node.argument\n            ])));\n        }\n    }\n};\n//# sourceMappingURL=perform-visitor.js.map","// 20.1.2.4 Number.isNaN(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare\n    return number != number;\n  }\n});\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass TokenType {\n  constructor(label, conf = {}) {\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n\n}\nconst keywords = new Map();\n\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = new TokenType(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name, binop) {\n  return new TokenType(name, {\n    beforeExpr,\n    binop\n  });\n}\n\nconst types = {\n  num: new TokenType(\"num\", {\n    startsExpr\n  }),\n  bigint: new TokenType(\"bigint\", {\n    startsExpr\n  }),\n  regexp: new TokenType(\"regexp\", {\n    startsExpr\n  }),\n  string: new TokenType(\"string\", {\n    startsExpr\n  }),\n  name: new TokenType(\"name\", {\n    startsExpr\n  }),\n  eof: new TokenType(\"eof\"),\n  bracketL: new TokenType(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: new TokenType(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", {\n    beforeExpr\n  }),\n  semi: new TokenType(\";\", {\n    beforeExpr\n  }),\n  colon: new TokenType(\":\", {\n    beforeExpr\n  }),\n  doubleColon: new TokenType(\"::\", {\n    beforeExpr\n  }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", {\n    beforeExpr\n  }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", {\n    beforeExpr\n  }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", {\n    beforeExpr\n  }),\n  backQuote: new TokenType(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: new TokenType(\"#!...\"),\n  eq: new TokenType(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: new TokenType(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: new TokenType(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 2),\n  logicalAND: createBinop(\"&&\", 3),\n  bitwiseOR: createBinop(\"|\", 4),\n  bitwiseXOR: createBinop(\"^\", 5),\n  bitwiseAND: createBinop(\"&\", 6),\n  equality: createBinop(\"==/!=/===/!==\", 7),\n  relational: createBinop(\"</>/<=/>=\", 8),\n  bitShift: createBinop(\"<</>>/>>>\", 9),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr,\n    binop: 10,\n    prefix,\n    startsExpr\n  }),\n  modulo: new TokenType(\"%\", {\n    beforeExpr,\n    binop: 11,\n    startsExpr\n  }),\n  star: createBinop(\"*\", 11),\n  slash: createBinop(\"/\", 11),\n  exponent: new TokenType(\"**\", {\n    beforeExpr,\n    binop: 12,\n    rightAssociative: true\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 8\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 8\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  perform: createKeyword(\"perform\", {\n    prefix,\n    startsExpr,\n    beforeExpr\n  }),\n  handle: createKeyword(\"handle\", {\n    prefix,\n    startsExpr,\n    beforeExpr\n  }),\n  recall: createKeyword(\"recall\", {\n    prefix,\n    startsExpr,\n    beforeExpr\n  })\n};\n\nconst SCOPE_OTHER = 0b0000000000,\n      SCOPE_PROGRAM = 0b0000000001,\n      SCOPE_FUNCTION = 0b0000000010,\n      SCOPE_ASYNC = 0b0000000100,\n      SCOPE_GENERATOR = 0b0000001000,\n      SCOPE_ARROW = 0b0000010000,\n      SCOPE_SIMPLE_CATCH = 0b0000100000,\n      SCOPE_SUPER = 0b0001000000,\n      SCOPE_DIRECT_SUPER = 0b0010000000,\n      SCOPE_CLASS = 0b0100000000,\n      SCOPE_TS_MODULE = 0b1000000000,\n      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\nfunction functionFlags(isAsync, isGenerator) {\n  return SCOPE_FUNCTION | (isAsync ? SCOPE_ASYNC : 0) | (isGenerator ? SCOPE_GENERATOR : 0);\n}\nconst BIND_KIND_VALUE = 0b00000000001,\n      BIND_KIND_TYPE = 0b00000000010,\n      BIND_SCOPE_VAR = 0b00000000100,\n      BIND_SCOPE_LEXICAL = 0b00000001000,\n      BIND_SCOPE_FUNCTION = 0b00000010000,\n      BIND_FLAGS_NONE = 0b00001000000,\n      BIND_FLAGS_CLASS = 0b00010000000,\n      BIND_FLAGS_TS_ENUM = 0b00100000000,\n      BIND_FLAGS_TS_CONST_ENUM = 0b01000000000,\n      BIND_FLAGS_TS_EXPORT_ONLY = 0b10000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;\n\nfunction isSimpleProperty(node) {\n  return node != null && node.type === \"Property\" && node.kind === \"init\" && node.method === false;\n}\n\nvar estree = (superClass => class extends superClass {\n  estreeParseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  estreeParseBigIntLiteral(value) {\n    const bigInt = typeof BigInt !== \"undefined\" ? BigInt(value) : null;\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  directiveToStmt(directive) {\n    const directiveLiteral = directive.value;\n    const stmt = this.startNodeAt(directive.start, directive.loc.start);\n    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n    expression.value = directiveLiteral.value;\n    expression.raw = directiveLiteral.extra.raw;\n    stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n    return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n\n  checkDeclaration(node) {\n    if (isSimpleProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n\n  checkGetterSetterParams(method) {\n    const prop = method;\n    const paramCount = prop.kind === \"get\" ? 0 : 1;\n    const start = prop.start;\n\n    if (prop.value.params.length !== paramCount) {\n      if (prop.kind === \"get\") {\n        this.raise(start, \"getter must not have any formal parameters\");\n      } else {\n        this.raise(start, \"setter must have exactly one formal parameter\");\n      }\n    } else if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n      this.raise(start, \"setter function argument must not be a rest parameter\");\n    }\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding) {\n    switch (expr.type) {\n      case \"ObjectPattern\":\n        expr.properties.forEach(prop => {\n          this.checkLVal(prop.type === \"Property\" ? prop.value : prop, bindingType, checkClashes, \"object destructuring pattern\", disallowLetBinding);\n        });\n        break;\n\n      default:\n        super.checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding);\n    }\n  }\n\n  checkDuplicatedProto(prop, protoRef) {\n    if (prop.type === \"SpreadElement\" || prop.computed || prop.method || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n    if (name === \"__proto__\" && prop.kind === \"init\") {\n      if (protoRef.used && !protoRef.start) {\n        protoRef.start = key.start;\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  isStrictBody(node) {\n    const isBlockStatement = node.body.type === \"BlockStatement\";\n\n    if (isBlockStatement && node.body.body.length > 0) {\n      for (let _i = 0, _node$body$body = node.body.body; _i < _node$body$body.length; _i++) {\n        const directive = _node$body$body[_i];\n\n        if (directive.type === \"ExpressionStatement\" && directive.expression.type === \"Literal\") {\n          if (directive.expression.value === \"use strict\") return true;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);\n  }\n\n  stmtToDirective(stmt) {\n    const directive = super.stmtToDirective(stmt);\n    const value = stmt.expression.value;\n    directive.value.value = value;\n    return directive;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n\n    classBody.body.push(method);\n  }\n\n  parseExprAtom(refShorthandDefaultPos) {\n    switch (this.state.type) {\n      case types.num:\n      case types.string:\n        return this.estreeParseLiteral(this.state.value);\n\n      case types.regexp:\n        return this.estreeParseRegExpLiteral(this.state.value);\n\n      case types.bigint:\n        return this.estreeParseBigIntLiteral(this.state.value);\n\n      case types._null:\n        return this.estreeParseLiteral(null);\n\n      case types._true:\n        return this.estreeParseLiteral(true);\n\n      case types._false:\n        return this.estreeParseLiteral(false);\n\n      default:\n        return super.parseExprAtom(refShorthandDefaultPos);\n    }\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    const node = super.parseLiteral(value, type, startPos, startLoc);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    type = type === \"ClassMethod\" ? \"MethodDefinition\" : type;\n    return this.finishNode(node, type);\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc);\n\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") node.kind = \"init\";\n      node.shorthand = false;\n    }\n\n    return node;\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {\n    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);\n\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n\n    return node;\n  }\n\n  toAssignable(node, isBinding, contextDescription) {\n    if (isSimpleProperty(node)) {\n      this.toAssignable(node.value, isBinding, contextDescription);\n      return node;\n    }\n\n    return super.toAssignable(node, isBinding, contextDescription);\n  }\n\n  toAssignableObjectExpressionProp(prop, isBinding, isLast) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      throw this.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n    } else if (prop.method) {\n      throw this.raise(prop.key.start, \"Object pattern can't contain methods\");\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isBinding, isLast);\n    }\n  }\n\n  finishCallExpression(node, optional) {\n    super.finishCallExpression(node, optional);\n\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      delete node.arguments;\n      delete node.callee;\n    }\n\n    return node;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    if (!exprList) {\n      return;\n    }\n\n    super.toReferencedListDeep(exprList, isParenthesizedExpr);\n  }\n\n});\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass TokContext {\n  constructor(token, isExpr, preserveSpace, override) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n  }\n\n}\nconst types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  templateQuasi: new TokContext(\"${\", false),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, p => p.readTmplToken()),\n  functionExpression: new TokContext(\"function\", true),\n  functionStatement: new TokContext(\"function\", false)\n};\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  let out = this.state.context.pop();\n\n  if (out === types$1.braceStatement && this.curContext().token === \"function\") {\n    out = this.state.context.pop();\n  }\n\n  this.state.exprAllowed = !out.isExpr;\n};\n\ntypes.name.updateContext = function (prevType) {\n  let allowed = false;\n\n  if (prevType !== types.dot) {\n    if (this.state.value === \"of\" && !this.state.exprAllowed || this.state.value === \"yield\" && this.scope.inGenerator) {\n      allowed = true;\n    }\n  }\n\n  this.state.exprAllowed = allowed;\n\n  if (this.state.isIterator) {\n    this.state.isIterator = false;\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {};\n\ntypes._function.updateContext = types._class.updateContext = function (prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n    this.state.context.push(types$1.functionExpression);\n  } else {\n    this.state.context.push(types$1.functionStatement);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n\n  this.state.exprAllowed = false;\n};\n\nconst reservedWords = {\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nconst isReservedWord = (word, inModule) => {\n  return inModule && word === \"await\" || word === \"enum\";\n};\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nconst keywordRelationalOperator = /^in(stanceof)?$/;\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIteratorStart(current, next) {\n  return current === 64 && next === 64;\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(state) {\n  return (state.type === types.name || !!state.type.keyword) && state.value !== \"from\";\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass => class extends superClass {\n  constructor(options, input) {\n    super(options, input);\n    this.flowPragma = undefined;\n  }\n\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n\n  finishToken(type, val) {\n    if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n\n    return super.finishToken(type, val);\n  }\n\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n\n      if (!matches) ; else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n\n    return super.addComment(comment);\n  }\n\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || types.colon);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    const moduloPos = this.state.start;\n    this.expect(types.modulo);\n    const checksLoc = this.state.startLoc;\n    this.expectContextual(\"checks\");\n\n    if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n      this.raise(moduloPos, \"Spaces between % and checks are not allowed here.\");\n    }\n\n    if (this.eat(types.parenL)) {\n      node.value = this.parseExpression();\n      this.expect(types.parenR);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(types.colon);\n    let type = null;\n    let predicate = null;\n\n    if (this.match(types.modulo)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n\n      if (this.match(types.modulo)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n\n    return [type, predicate];\n  }\n\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n\n    if (this.isRelational(\"<\")) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n\n    this.expect(types.parenL);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    this.expect(types.parenR);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n\n  flowParseDeclare(node, insideModule) {\n    if (this.match(types._class)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(types._function)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(types._var)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(\"module\")) {\n      if (this.match(types.dot)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(this.state.lastTokStart, \"`declare module` cannot be used inside another `declare module`\");\n        }\n\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(\"type\")) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(\"opaque\")) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(\"interface\")) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(types._export)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, BIND_VAR, node.id.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n\n  flowParseDeclareModule(node) {\n    this.scope.enter(SCOPE_OTHER);\n\n    if (this.match(types.string)) {\n      node.id = this.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(types.braceL);\n\n    while (!this.match(types.braceR)) {\n      let bodyNode = this.startNode();\n\n      if (this.match(types._import)) {\n        this.next();\n\n        if (!this.isContextual(\"type\") && !this.match(types._typeof)) {\n          this.raise(this.state.lastTokStart, \"Imports within a `declare module` body must always be `import type` or `import typeof`\");\n        }\n\n        this.parseImport(bodyNode);\n      } else {\n        this.expectContextual(\"declare\", \"Only declares and type imports are allowed inside declare module\");\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n\n      body.push(bodyNode);\n    }\n\n    this.scope.exit();\n    this.expect(types.braceR);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    const errorMessage = \"Found both `declare module.exports` and `declare export` in the same module. \" + \"Modules can only have 1 since they are either an ES module or they are a CommonJS module\";\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(bodyElement.start, errorMessage);\n        }\n\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(bodyElement.start, \"Duplicate `declare module.exports` statement\");\n        }\n\n        if (kind === \"ES\") this.raise(bodyElement.start, errorMessage);\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(types._export);\n\n    if (this.eat(types._default)) {\n      if (this.match(types._function) || this.match(types._class)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(types._const) || this.isLet() || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !insideModule) {\n        const label = this.state.value;\n        const suggestion = exportSuggestions[label];\n        this.unexpected(this.state.start, `\\`declare export ${label}\\` is not supported. Use \\`${suggestion}\\` instead`);\n      }\n\n      if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual(\"opaque\")) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual(\"interface\") || this.isContextual(\"type\") || this.isContextual(\"opaque\")) {\n          node = this.parseExport(node);\n\n          if (node.type === \"ExportNamedDeclaration\") {\n            node.type = \"ExportDeclaration\";\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          node.type = \"Declare\" + node.type;\n          return node;\n        }\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(\"exports\");\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    this.flowParseTypeAlias(node);\n    node.type = \"DeclareTypeAlias\";\n    return node;\n  }\n\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    this.flowParseOpaqueType(node, true);\n    node.type = \"DeclareOpaqueType\";\n    return node;\n  }\n\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n\n  flowParseInterfaceish(node, isClass = false) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.extends = [];\n    node.implements = [];\n    node.mixins = [];\n\n    if (this.eat(types._extends)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(types.comma));\n    }\n\n    if (this.isContextual(\"mixins\")) {\n      this.next();\n\n      do {\n        node.mixins.push(this.flowParseInterfaceExtends());\n      } while (this.eat(types.comma));\n    }\n\n    if (this.isContextual(\"implements\")) {\n      this.next();\n\n      do {\n        node.implements.push(this.flowParseInterfaceExtends());\n      } while (this.eat(types.comma));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(this.state.start, \"`_` is only allowed as a type argument to call or new\");\n    }\n  }\n\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n\n    if (declaration) {\n      this.raise(startLoc, `Cannot overwrite reserved type ${word}`);\n      return;\n    }\n\n    this.raise(startLoc, `Unexpected reserved type ${word}`);\n  }\n\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.start, declaration);\n    return this.parseIdentifier(liberal);\n  }\n\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.right = this.flowParseTypeInitialiser(types.eq);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(\"type\");\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.supertype = null;\n\n    if (this.match(types.colon)) {\n      node.supertype = this.flowParseTypeInitialiser(types.colon);\n    }\n\n    node.impltype = null;\n\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(types.eq);\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStart = this.state.start;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n\n    if (this.match(types.eq)) {\n      this.eat(types.eq);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(nodeStart, \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\");\n      }\n    }\n\n    return this.finishNode(node, \"TypeParameter\");\n  }\n\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n\n    if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    let defaultRequired = false;\n\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n\n      if (!this.isRelational(\">\")) {\n        this.expect(types.comma);\n      }\n    } while (!this.isRelational(\">\"));\n\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expectRelational(\"<\");\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n\n    while (!this.isRelational(\">\")) {\n      node.params.push(this.flowParseType());\n\n      if (!this.isRelational(\">\")) {\n        this.expect(types.comma);\n      }\n    }\n\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expectRelational(\"<\");\n\n    while (!this.isRelational(\">\")) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n\n      if (!this.isRelational(\">\")) {\n        this.expect(types.comma);\n      }\n    }\n\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(\"interface\");\n    node.extends = [];\n\n    if (this.eat(types._extends)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(types.comma));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n\n  flowParseObjectPropertyKey() {\n    return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n  }\n\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n\n    if (this.lookahead().type === types.colon) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n\n    this.expect(types.bracketR);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(types.bracketR);\n    this.expect(types.bracketR);\n\n    if (this.isRelational(\"<\") || this.match(types.parenL)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n    } else {\n      node.method = false;\n\n      if (this.eat(types.question)) {\n        node.optional = true;\n      }\n\n      node.value = this.flowParseTypeInitialiser();\n    }\n\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    this.expect(types.parenL);\n\n    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n      node.params.push(this.flowParseFunctionTypeParam());\n\n      if (!this.match(types.parenR)) {\n        this.expect(types.comma);\n      }\n    }\n\n    if (this.eat(types.ellipsis)) {\n      node.rest = this.flowParseFunctionTypeParam();\n    }\n\n    this.expect(types.parenR);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n\n    if (allowExact && this.match(types.braceBarL)) {\n      this.expect(types.braceBarL);\n      endDelim = types.braceBarR;\n      exact = true;\n    } else {\n      this.expect(types.braceL);\n      endDelim = types.braceR;\n      exact = false;\n    }\n\n    nodeStart.exact = exact;\n\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStart = null;\n      let inexactStart = null;\n      const node = this.startNode();\n\n      if (allowProto && this.isContextual(\"proto\")) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n          this.next();\n          protoStart = this.state.start;\n          allowStatic = false;\n        }\n      }\n\n      if (allowStatic && this.isContextual(\"static\")) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n          this.next();\n          isStatic = true;\n        }\n      }\n\n      const variance = this.flowParseVariance();\n\n      if (this.eat(types.bracketL)) {\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (this.eat(types.bracketL)) {\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.unexpected(variance.start);\n        }\n\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n\n        if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStart = this.state.lastTokStart;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n\n      this.flowObjectTypeSemicolon();\n\n      if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n        this.raise(inexactStart, \"Explicit inexact syntax must appear at the end of an inexact object\");\n      }\n    }\n\n    this.expect(endDelim);\n\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n\n  flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(types.ellipsis)) {\n      const isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);\n\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(this.state.lastTokStart, \"Explicit inexact syntax cannot appear in class or interface definitions\");\n        } else if (!allowInexact) {\n          this.raise(this.state.lastTokStart, \"Explicit inexact syntax cannot appear inside an explicit exact object type\");\n        }\n\n        if (variance) {\n          this.raise(variance.start, \"Explicit inexact syntax cannot have variance\");\n        }\n\n        return null;\n      }\n\n      if (!allowSpread) {\n        this.raise(this.state.lastTokStart, \"Spread operator cannot appear in class or interface definitions\");\n      }\n\n      if (protoStart != null) {\n        this.unexpected(protoStart);\n      }\n\n      if (variance) {\n        this.raise(variance.start, \"Spread properties cannot have variance\");\n      }\n\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStart != null;\n      node.kind = kind;\n      let optional = false;\n\n      if (this.isRelational(\"<\") || this.match(types.parenL)) {\n        node.method = true;\n\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.unexpected(variance.start);\n        }\n\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n\n        if (this.eat(types.question)) {\n          optional = true;\n        }\n\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const start = property.start;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n    if (length !== paramCount) {\n      if (property.kind === \"get\") {\n        this.raise(start, \"getter must not have any formal parameters\");\n      } else {\n        this.raise(start, \"setter must have exactly one formal parameter\");\n      }\n    }\n\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(start, \"setter function argument must not be a rest parameter\");\n    }\n  }\n\n  flowObjectTypeSemicolon() {\n    if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n      this.unexpected();\n    }\n  }\n\n  flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n\n    while (this.eat(types.dot)) {\n      const node2 = this.startNodeAt(startPos, startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n\n    return node;\n  }\n\n  flowParseGenericType(startPos, startLoc, id) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(types._typeof);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(types.bracketL);\n\n    while (this.state.pos < this.length && !this.match(types.bracketR)) {\n      node.types.push(this.flowParseType());\n      if (this.match(types.bracketR)) break;\n      this.expect(types.comma);\n    }\n\n    this.expect(types.bracketR);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n\n  flowParseFunctionTypeParam() {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n\n    if (lh.type === types.colon || lh.type === types.question) {\n      name = this.parseIdentifier();\n\n      if (this.eat(types.question)) {\n        optional = true;\n      }\n\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.start, type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n\n    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n      params.push(this.flowParseFunctionTypeParam());\n\n      if (!this.match(types.parenR)) {\n        this.expect(types.comma);\n      }\n    }\n\n    if (this.eat(types.ellipsis)) {\n      rest = this.flowParseFunctionTypeParam();\n    }\n\n    return {\n      params,\n      rest\n    };\n  }\n\n  flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startPos, startLoc, id);\n    }\n  }\n\n  flowParsePrimaryType() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n    switch (this.state.type) {\n      case types.name:\n        if (this.isContextual(\"interface\")) {\n          return this.flowParseInterfaceType();\n        }\n\n        return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n      case types.braceL:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n\n      case types.braceBarL:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n\n      case types.bracketL:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n\n      case types.relational:\n        if (this.state.value === \"<\") {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(types.parenL);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          this.expect(types.parenR);\n          this.expect(types.arrow);\n          node.returnType = this.flowParseType();\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n\n        break;\n\n      case types.parenL:\n        this.next();\n\n        if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n          if (this.match(types.name)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== types.question && token !== types.colon;\n          } else {\n            isGroupedType = true;\n          }\n        }\n\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n            this.expect(types.parenR);\n            return type;\n          } else {\n            this.eat(types.comma);\n          }\n        }\n\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        this.expect(types.parenR);\n        this.expect(types.arrow);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n      case types._true:\n      case types._false:\n        node.value = this.match(types._true);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n      case types.plusMin:\n        if (this.state.value === \"-\") {\n          this.next();\n\n          if (this.match(types.num)) {\n            return this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", node.start, node.loc.start);\n          }\n\n          if (this.match(types.bigint)) {\n            return this.parseLiteral(-this.state.value, \"BigIntLiteralTypeAnnotation\", node.start, node.loc.start);\n          }\n\n          throw this.raise(this.state.start, `Unexpected token, expected \"number\" or \"bigint\"`);\n        }\n\n        this.unexpected();\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n      case types._void:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n\n      case types._null:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n      case types._this:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n\n      case types.star:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n      default:\n        if (this.state.type.keyword === \"typeof\") {\n          return this.flowParseTypeofType();\n        } else if (this.state.type.keyword) {\n          const label = this.state.type.label;\n          this.next();\n          return super.createIdentifier(node, label);\n        }\n\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParsePostfixType() {\n    const startPos = this.state.start,\n          startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n\n    while (this.match(types.bracketL) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.elementType = type;\n      this.expect(types.bracketL);\n      this.expect(types.bracketR);\n      type = this.finishNode(node, \"ArrayTypeAnnotation\");\n    }\n\n    return type;\n  }\n\n  flowParsePrefixType() {\n    const node = this.startNode();\n\n    if (this.eat(types.question)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n\n    if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n      const node = this.startNodeAt(param.start, param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    return param;\n  }\n\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(types.bitwiseAND);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n\n    while (this.eat(types.bitwiseAND)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(types.bitwiseOR);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n\n    while (this.eat(types.bitwiseOR)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;\n    return type;\n  }\n\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === types.name && this.state.value === \"_\") {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startPos, startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n    if (this.match(types.colon)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n\n    return ident;\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  flowParseVariance() {\n    let variance = null;\n\n    if (this.match(types.plusMin)) {\n      variance = this.startNode();\n\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n\n      this.next();\n      this.finishNode(variance, \"Variance\");\n    }\n\n    return variance;\n  }\n\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n    }\n\n    return super.parseFunctionBody(node, false, isMethod);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(types.colon)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseInterface(node);\n    } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    } else {\n      const stmt = super.parseStatement(context, topLevel);\n\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n\n      return stmt;\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (this.match(types.name)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n\n    return super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || this.shouldParseEnums() && this.isContextual(\"enum\") || super.shouldParseExportDeclaration();\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value === \"opaque\" || this.shouldParseEnums() && this.state.value === \"enum\")) {\n      return false;\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (!this.match(types.question)) return expr;\n\n    if (refNeedsArrowPos) {\n      const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));\n\n      if (!result.node) {\n        refNeedsArrowPos.start = result.error.pos || this.state.start;\n        return expr;\n      }\n\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    this.expect(types.question);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startPos, startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n\n      if (failed && valid.length > 1) {\n        this.raise(state.start, \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\");\n      }\n\n      if (failed && valid.length === 1) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt.concat(valid[0].start);\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(types.colon);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(noIn, undefined, undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssign();\n    const failed = !this.match(types.colon);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n\n    while (stack.length !== 0) {\n      const node = stack.pop();\n\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n\n  finishArrowValidation(node) {\n    var _node$extra;\n\n    this.toAssignableList(node.params, true, \"arrow function parameters\", (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma);\n    this.scope.enter(functionFlags(false, false) | SCOPE_ARROW);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n\n    return result;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(types.question)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(types.colon)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n\n    super.assertModuleNodeAllowed(node);\n  }\n\n  parseExport(node) {\n    const decl = super.parseExport(node);\n\n    if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n      decl.exportKind = decl.exportKind || \"value\";\n    }\n\n    return decl;\n  }\n\n  parseExportDeclaration(node) {\n    if (this.isContextual(\"type\")) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n\n      if (this.match(types.braceL)) {\n        node.specifiers = this.parseExportSpecifiers();\n        this.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(\"opaque\")) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(\"interface\")) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n\n  eatExportStar(node) {\n    if (super.eatExportStar(...arguments)) return true;\n\n    if (this.isContextual(\"type\") && this.lookahead().type === types.star) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    const pos = this.state.start;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(pos);\n    }\n\n    return hasNamespace;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 123 && next === 124) {\n      return this.finishOp(types.braceBarL, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(types.relational, 1);\n    } else if (isIteratorStart(code, next)) {\n      this.state.isIterator = true;\n      return super.readWord();\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        return true;\n\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type === \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return node.elements.every(element => this.isAssignable(element));\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n      case \"TypeCastExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  toAssignable(node, isBinding, contextDescription) {\n    if (node.type === \"TypeCastExpression\") {\n      return super.toAssignable(this.typeCastToParameter(node), isBinding, contextDescription);\n    } else {\n      return super.toAssignable(node, isBinding, contextDescription);\n    }\n  }\n\n  toAssignableList(exprList, isBinding, contextDescription, trailingCommaPos) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n\n    return super.toAssignableList(exprList, isBinding, contextDescription, trailingCommaPos);\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TypeCastExpression\" && (!expr.extra || !expr.extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(expr.typeAnnotation.start, \"The type cast expression is expected to be wrapped with parenthesis\");\n      }\n    }\n\n    return exprList;\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {\n    if (expr.type !== \"TypeCastExpression\") {\n      return super.checkLVal(expr, bindingType, checkClashes, contextDescription);\n    }\n  }\n\n  parseClassProperty(node) {\n    if (this.match(types.colon)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (this.match(types.colon)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassPrivateProperty(node);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(types.colon) || super.isClassProperty();\n  }\n\n  isNonstaticConstructor(method) {\n    return !this.match(types.colon) && super.isNonstaticConstructor(method);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.start);\n    }\n\n    delete method.variance;\n\n    if (this.isRelational(\"<\")) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.start);\n    }\n\n    delete method.variance;\n\n    if (this.isRelational(\"<\")) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    if (this.isContextual(\"implements\")) {\n      this.next();\n      const implemented = node.implements = [];\n\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(types.comma));\n    }\n  }\n\n  parsePropertyName(node) {\n    const variance = this.flowParseVariance();\n    const key = super.parsePropertyName(node);\n    node.variance = variance;\n    return key;\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.start);\n    }\n\n    delete prop.variance;\n    let typeParameters;\n\n    if (this.isRelational(\"<\")) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(types.parenL)) this.unexpected();\n    }\n\n    super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);\n\n    if (typeParameters) {\n      (prop.value || prop).typeParameters = typeParameters;\n    }\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(types.question)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(param.start, \"A binding pattern parameter cannot be optional in an implementation signature.\");\n      }\n\n      param.optional = true;\n    }\n\n    if (this.match(types.colon)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, \"Type annotations must come before default assignments, \" + \"e.g. instead of `age = 25: number` use `age: number = 25`\");\n    }\n\n    return node;\n  }\n\n  shouldParseDefaultImport(node) {\n    if (!hasTypeImportKind(node)) {\n      return super.shouldParseDefaultImport(node);\n    }\n\n    return isMaybeDefaultImport(this.state);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    node.importKind = \"value\";\n    let kind = null;\n\n    if (this.match(types._typeof)) {\n      kind = \"typeof\";\n    } else if (this.isContextual(\"type\")) {\n      kind = \"type\";\n    }\n\n    if (kind) {\n      const lh = this.lookahead();\n\n      if (kind === \"type\" && lh.type === types.star) {\n        this.unexpected(lh.start);\n      }\n\n      if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {\n        this.next();\n        node.importKind = kind;\n      }\n    }\n\n    return super.maybeParseDefaultImportSpecifier(node);\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    const firstIdentLoc = this.state.start;\n    const firstIdent = this.parseIdentifier(true);\n    let specifierTypeKind = null;\n\n    if (firstIdent.name === \"type\") {\n      specifierTypeKind = \"type\";\n    } else if (firstIdent.name === \"typeof\") {\n      specifierTypeKind = \"typeof\";\n    }\n\n    let isBinding = false;\n\n    if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n\n      if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = as_ident.__clone();\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n      specifier.imported = this.parseIdentifier(true);\n      specifier.importKind = specifierTypeKind;\n\n      if (this.eatContextual(\"as\")) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = specifier.imported.__clone();\n      }\n    } else {\n      isBinding = true;\n      specifier.imported = firstIdent;\n      specifier.importKind = null;\n      specifier.local = specifier.imported.__clone();\n    }\n\n    const nodeIsTypeImport = hasTypeImportKind(node);\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n    if (nodeIsTypeImport && specifierIsTypeImport) {\n      this.raise(firstIdentLoc, \"The `type` and `typeof` keywords on named imports can only be used on regular \" + \"`import` statements. It cannot be used with `import type` or `import typeof` statements\");\n    }\n\n    if (nodeIsTypeImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.start, true);\n    }\n\n    if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n    }\n\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, \"import specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const kind = node.kind;\n\n    if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (this.match(types.colon)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(types.colon)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.colon) || super.shouldParseAsyncArrow();\n  }\n\n  parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {\n    let state = null;\n    let jsx;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(types.jsxTagStart) || this.isRelational(\"<\"))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types$1.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types$1.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (jsx && jsx.error || this.isRelational(\"<\")) {\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(() => {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => super.parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos));\n        arrowExpression.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(arrowExpression, typeParameters);\n        return arrowExpression;\n      }, state);\n      const arrowExpression = arrow.node && arrow.node.type === \"ArrowFunctionExpression\" ? arrow.node : null;\n      if (!arrow.error && arrowExpression) return arrowExpression;\n\n      if (jsx && jsx.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n\n      if (jsx && jsx.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(typeParameters.start, \"Expected an arrow function after this type parameter declaration\");\n    }\n\n    return super.parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);\n  }\n\n  parseArrow(node) {\n    if (this.match(types.colon)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(types.arrow)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n\n    return super.parseArrow(node);\n  }\n\n  shouldParseArrow() {\n    return this.match(types.colon) || super.shouldParseArrow();\n  }\n\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n\n    return super.checkParams(...arguments);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.isRelational(\"<\")) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n\n      throw arrow.error || result.error;\n    }\n\n    return super.parseSubscripts(base, startPos, startLoc, noCalls);\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {\n    if (this.match(types.questionDot) && this.isLookaheadRelational(\"<\")) {\n      this.expectPlugin(\"optionalChaining\");\n      subscriptState.optionalChainMember = true;\n\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(types.parenL);\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.isRelational(\"<\")) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(types.parenL);\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        if (subscriptState.optionalChainMember) node.optional = false;\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);\n  }\n\n  parseNewArguments(node) {\n    let targs = null;\n\n    if (this.shouldParseTypes() && this.isRelational(\"<\")) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n\n    node.typeArguments = targs;\n    super.parseNewArguments(node);\n  }\n\n  parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.parseFunctionParams(node);\n    if (!this.parseArrow(node)) return;\n    return this.parseArrowExpression(node, undefined, true);\n  }\n\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n\n    super.readToken_mult_modulo(code);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 124 && next === 125) {\n      this.finishOp(types.braceBarR, 2);\n      return;\n    }\n\n    super.readToken_pipe_amp(code);\n  }\n\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n\n    if (this.state.hasFlowComment) {\n      this.raise(this.state.pos, \"Unterminated flow-comment\");\n    }\n\n    return fileNode;\n  }\n\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        this.unexpected(null, \"Cannot have a flow comment inside another flow comment\");\n      }\n\n      this.hasFlowCommentCompletion();\n      this.state.pos += this.skipFlowComment();\n      this.state.hasFlowComment = true;\n      return;\n    }\n\n    if (this.state.hasFlowComment) {\n      const end = this.input.indexOf(\"*-/\", this.state.pos += 2);\n\n      if (end === -1) {\n        throw this.raise(this.state.pos - 2, \"Unterminated comment\");\n      }\n\n      this.state.pos = end + 3;\n      return;\n    }\n\n    super.skipBlockComment();\n  }\n\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n\n    return false;\n  }\n\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n\n    if (end === -1) {\n      throw this.raise(this.state.pos, \"Unterminated comment\");\n    }\n  }\n\n  flowEnumErrorBooleanMemberNotInitialized(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` ` + `or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`);\n  }\n\n  flowEnumErrorInvalidMemberName(pos, {\n    enumName,\n    memberName\n  }) {\n    const suggestion = memberName[0].toUpperCase() + memberName.slice(1);\n    this.raise(pos, `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using ` + `\\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`);\n  }\n\n  flowEnumErrorDuplicateMemberName(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used ` + `before in enum \\`${enumName}\\`.`);\n  }\n\n  flowEnumErrorInconsistentMemberValues(pos, {\n    enumName\n  }) {\n    this.raise(pos, `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or ` + `consistently use literals (either booleans, numbers, or strings) for all member initializers.`);\n  }\n\n  flowEnumErrorInvalidExplicitType(pos, {\n    enumName,\n    suppliedType\n  }) {\n    const suggestion = `Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in ` + `enum \\`${enumName}\\`.`;\n    const message = suppliedType === null ? `Supplied enum type is not valid. ${suggestion}` : `Enum type \\`${suppliedType}\\` is not valid. ${suggestion}`;\n    return this.raise(pos, message);\n  }\n\n  flowEnumErrorInvalidMemberInitializer(pos, {\n    enumName,\n    explicitType,\n    memberName\n  }) {\n    let message = null;\n\n    switch (explicitType) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        message = `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of ` + `\\`${memberName}\\` needs to be a ${explicitType} literal.`;\n        break;\n\n      case \"symbol\":\n        message = `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in ` + `enum \\`${enumName}\\`.`;\n        break;\n\n      default:\n        message = `The enum member initializer for \\`${memberName}\\` needs to be a literal (either ` + `a boolean, number, or string) in enum \\`${enumName}\\`.`;\n    }\n\n    return this.raise(pos, message);\n  }\n\n  flowEnumErrorNumberMemberNotInitialized(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`);\n  }\n\n  flowEnumErrorStringMemberInconsistentlyInitailized(pos, {\n    enumName\n  }) {\n    this.raise(pos, `String enum members need to consistently either all use initializers, or use no initializers, ` + `in enum \\`${enumName}\\`.`);\n  }\n\n  flowEnumMemberInit() {\n    const startPos = this.state.start;\n\n    const endOfInit = () => this.match(types.comma) || this.match(types.braceR);\n\n    switch (this.state.type) {\n      case types.num:\n        {\n          const literal = this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      case types.string:\n        {\n          const literal = this.parseLiteral(this.state.value, \"StringLiteral\");\n\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      case types._true:\n      case types._false:\n        {\n          const literal = this.parseBooleanLiteral();\n\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      default:\n        return {\n          type: \"invalid\",\n          pos: startPos\n        };\n    }\n  }\n\n  flowEnumMemberRaw() {\n    const pos = this.state.start;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(types.eq) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      pos\n    };\n    return {\n      id,\n      init\n    };\n  }\n\n  flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n\n    if (explicitType === null) {\n      return;\n    }\n\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(pos, context);\n    }\n  }\n\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n\n    while (!this.match(types.braceR)) {\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n\n      if (memberName === \"\") {\n        continue;\n      }\n\n      if (/^[a-z]/.test(memberName)) {\n        this.flowEnumErrorInvalidMemberName(id.start, {\n          enumName,\n          memberName\n        });\n      }\n\n      if (seenNames.has(memberName)) {\n        this.flowEnumErrorDuplicateMemberName(id.start, {\n          enumName,\n          memberName\n        });\n      }\n\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);\n          }\n\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);\n                break;\n\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);\n                break;\n\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n\n      if (!this.match(types.braceR)) {\n        this.expect(types.comma);\n      }\n    }\n\n    return members;\n  }\n\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (let _i = 0; _i < initializedMembers.length; _i++) {\n        const member = initializedMembers[_i];\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n          enumName\n        });\n      }\n\n      return defaultedMembers;\n    } else {\n      for (let _i2 = 0; _i2 < defaultedMembers.length; _i2++) {\n        const member = defaultedMembers[_i2];\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n          enumName\n        });\n      }\n\n      return initializedMembers;\n    }\n  }\n\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (this.eatContextual(\"of\")) {\n      if (!this.match(types.name)) {\n        throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n          enumName,\n          suppliedType: null\n        });\n      }\n\n      const {\n        value\n      } = this.state;\n      this.next();\n\n      if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n        this.flowEnumErrorInvalidExplicitType(this.state.start, {\n          enumName,\n          suppliedType: value\n        });\n      }\n\n      return value;\n    }\n\n    return null;\n  }\n\n  flowEnumBody(node, {\n    enumName,\n    nameLoc\n  }) {\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(types.braceL);\n    const members = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumBooleanBody\");\n\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumNumberBody\");\n\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumStringBody\");\n\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumSymbolBody\");\n\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (let _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {\n              const member = _members$defaultedMem[_i3];\n              this.flowEnumErrorBooleanMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.booleanMembers;\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (let _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {\n              const member = _members$defaultedMem2[_i4];\n              this.flowEnumErrorNumberMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.numberMembers;\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.flowEnumErrorInconsistentMemberValues(nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), {\n      enumName: id.name,\n      nameLoc: id.start\n    });\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n\n});\n\nconst entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", {\n  beforeExpr: true\n});\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", {\n  startsExpr: true\n});\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr);\n  this.state.context.push(types$1.j_oTag);\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  const out = this.state.context.pop();\n\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsx = (superClass => class extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, \"Unterminated JSX contents\");\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.exprAllowed) {\n              ++this.state.pos;\n              return this.finishToken(types.jsxTagStart);\n            }\n\n            return super.getTokenFromCode(ch);\n          }\n\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(types.jsxText, out);\n\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n\n      }\n    }\n  }\n\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, \"Unterminated string constant\");\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(types.string, out);\n  }\n\n  jsxReadEntity() {\n    let str = \"\";\n    let count = 0;\n    let entity;\n    let ch = this.input[this.state.pos];\n    const startPos = ++this.state.pos;\n\n    while (this.state.pos < this.length && count++ < 10) {\n      ch = this.input[this.state.pos++];\n\n      if (ch === \";\") {\n        if (str[0] === \"#\") {\n          if (str[1] === \"x\") {\n            str = str.substr(2);\n\n            if (HEX_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 16));\n            }\n          } else {\n            str = str.substr(1);\n\n            if (DECIMAL_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 10));\n            }\n          }\n        } else {\n          entity = entities[str];\n        }\n\n        break;\n      }\n\n      str += ch;\n    }\n\n    if (!entity) {\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    return entity;\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n\n    return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n\n    if (this.match(types.jsxName)) {\n      node.name = this.state.value;\n    } else if (this.state.type.keyword) {\n      node.name = this.state.type.keyword;\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(types.colon)) return name;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n\n    while (this.eat(types.dot)) {\n      const newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n\n    switch (this.state.type) {\n      case types.braceL:\n        node = this.startNode();\n        this.next();\n        node = this.jsxParseExpressionContainer(node);\n\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(node.start, \"JSX attributes must only be assigned a non-empty expression\");\n        }\n\n        return node;\n\n      case types.jsxTagStart:\n      case types.string:\n        return this.parseExprAtom();\n\n      default:\n        throw this.raise(this.state.start, \"JSX value should be either an expression or a quoted JSX text\");\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node) {\n    if (this.match(types.braceR)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      node.expression = this.parseExpression();\n    }\n\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n\n    if (this.eat(types.braceL)) {\n      this.expect(types.ellipsis);\n      node.argument = this.parseMaybeAssign();\n      this.expect(types.braceR);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n\n    while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n\n    node.attributes = attributes;\n    node.selfClosing = this.eat(types.slash);\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n    let closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case types.jsxTagStart:\n            startPos = this.state.start;\n            startLoc = this.state.startLoc;\n            this.next();\n\n            if (this.eat(types.slash)) {\n              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n\n            children.push(this.jsxParseElementAt(startPos, startLoc));\n            break;\n\n          case types.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case types.braceL:\n            {\n              const node = this.startNode();\n              this.next();\n\n              if (this.match(types.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node));\n              }\n\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      if (isFragment(openingElement) && !isFragment(closingElement)) {\n        this.raise(closingElement.start, \"Expected corresponding JSX closing tag for <>\");\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(closingElement.start, \"Expected corresponding JSX closing tag for <\" + getQualifiedJSXName(openingElement.name) + \">\");\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, \"Expected corresponding JSX closing tag for <\" + getQualifiedJSXName(openingElement.name) + \">\");\n        }\n      }\n    }\n\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n\n    node.children = children;\n\n    if (this.isRelational(\"<\")) {\n      throw this.raise(this.state.start, \"Adjacent JSX elements must be wrapped in an enclosing tag. \" + \"Did you want a JSX fragment <>...</>?\");\n    }\n\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startPos, startLoc);\n  }\n\n  parseExprAtom(refShortHandDefaultPos) {\n    if (this.match(types.jsxText)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(types.jsxTagStart)) {\n      return this.jsxParseElement();\n    } else if (this.isRelational(\"<\") && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.finishToken(types.jsxTagStart);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refShortHandDefaultPos);\n    }\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inPropertyName) return super.getTokenFromCode(code);\n    const context = this.curContext();\n\n    if (context === types$1.j_expr) {\n      return this.jsxReadToken();\n    }\n\n    if (context === types$1.j_oTag || context === types$1.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(types.jsxTagEnd);\n      }\n\n      if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n\n    if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(types.jsxTagStart);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  updateContext(prevType) {\n    if (this.match(types.braceL)) {\n      const curContext = this.curContext();\n\n      if (curContext === types$1.j_oTag) {\n        this.state.context.push(types$1.braceExpression);\n      } else if (curContext === types$1.j_expr) {\n        this.state.context.push(types$1.templateQuasi);\n      } else {\n        super.updateContext(prevType);\n      }\n\n      this.state.exprAllowed = true;\n    } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n      this.state.context.length -= 2;\n      this.state.context.push(types$1.j_cTag);\n      this.state.exprAllowed = false;\n    } else {\n      return super.updateContext(prevType);\n    }\n  }\n\n});\n\nclass Scope {\n  constructor(flags) {\n    this.var = [];\n    this.lexical = [];\n    this.functions = [];\n    this.flags = flags;\n  }\n\n}\nclass ScopeHandler {\n  constructor(raise, inModule) {\n    this.scopeStack = [];\n    this.undefinedExports = new Map();\n    this.raise = raise;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get inGenerator() {\n    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;\n  }\n\n  get inAsync() {\n    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;\n  }\n\n  get allowSuper() {\n    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;\n  }\n\n  get allowDirectSuper() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n  }\n\n  get inClass() {\n    return (this.currentThisScope().flags & SCOPE_CLASS) > 0;\n  }\n\n  get inNonArrowFunction() {\n    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags) {\n    return new Scope(flags);\n  }\n\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n\n  declareName(name, bindingType, pos) {\n    let scope = this.currentScope();\n\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.push(name);\n      } else {\n        scope.lexical.push(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        scope.var.push(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope, name) {\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(scope, name, bindingType, pos) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.raise(pos, `Identifier '${name}' has already been declared`);\n    }\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;\n    }\n\n    return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {\n      this.undefinedExports.set(id.name, id.start);\n    }\n  }\n\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if (scope.flags & SCOPE_VAR) {\n        return scope;\n      }\n    }\n  }\n\n  currentThisScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {\n        return scope;\n      }\n    }\n  }\n\n}\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = [];\n    this.enums = [];\n    this.constEnums = [];\n    this.classes = [];\n    this.exportOnlyBindings = [];\n  }\n\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        this.maybeExportDefined(scope, name);\n      }\n\n      scope.types.push(name);\n    }\n\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.indexOf(name) > -1) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.indexOf(name) > -1;\n        return isConst !== wasConst;\n      }\n\n      return true;\n    }\n\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {\n      if (scope.lexical.indexOf(name) > -1) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nvar typescript = (superClass => class extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n\n  tsIsIdentifier() {\n    return this.match(types.name);\n  }\n\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question) && !this.match(types.bang);\n  }\n\n  tsParseModifier(allowedModifiers) {\n    if (!this.match(types.name)) {\n      return undefined;\n    }\n\n    const modifier = this.state.value;\n\n    if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n      return modifier;\n    }\n\n    return undefined;\n  }\n\n  tsParseModifiers(allowedModifiers) {\n    const modifiers = Object.create(null);\n\n    while (true) {\n      const startPos = this.state.start;\n      const modifier = this.tsParseModifier(allowedModifiers);\n      if (!modifier) break;\n\n      if (Object.hasOwnProperty.call(modifiers, modifier)) {\n        this.raise(startPos, `Duplicate modifier: '${modifier}'`);\n      }\n\n      modifiers[modifier] = true;\n    }\n\n    return modifiers;\n  }\n\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(types.braceR);\n\n      case \"HeritageClauseElement\":\n        return this.match(types.braceL);\n\n      case \"TupleElementTypes\":\n        return this.match(types.bracketR);\n\n      case \"TypeParametersOrArguments\":\n        return this.isRelational(\">\");\n    }\n\n    throw new Error(\"Unreachable\");\n  }\n\n  tsParseList(kind, parseElement) {\n    const result = [];\n\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n\n    return result;\n  }\n\n  tsParseDelimitedList(kind, parseElement) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {\n    const result = [];\n\n    while (true) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      const element = parseElement();\n\n      if (element == null) {\n        return undefined;\n      }\n\n      result.push(element);\n\n      if (this.eat(types.comma)) {\n        continue;\n      }\n\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      if (expectSuccess) {\n        this.expect(types.comma);\n      }\n\n      return undefined;\n    }\n\n    return result;\n  }\n\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(types.bracketL);\n      } else {\n        this.expectRelational(\"<\");\n      }\n    }\n\n    const result = this.tsParseDelimitedList(kind, parseElement);\n\n    if (bracket) {\n      this.expect(types.bracketR);\n    } else {\n      this.expectRelational(\">\");\n    }\n\n    return result;\n  }\n\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(types._import);\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      this.raise(this.state.start, \"Argument in a type import must be a string literal\");\n    }\n\n    node.argument = this.parseExprAtom();\n    this.expect(types.parenR);\n\n    if (this.eat(types.dot)) {\n      node.qualifier = this.tsParseEntityName(true);\n    }\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSImportType\");\n  }\n\n  tsParseEntityName(allowReservedWords) {\n    let entity = this.parseIdentifier();\n\n    while (this.eat(types.dot)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n\n    return entity;\n  }\n\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(false);\n\n    if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(types._typeof);\n\n    if (this.match(types._import)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName(true);\n    }\n\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n\n  tsParseTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsEatThenParseType(types._extends);\n    node.default = this.tsEatThenParseType(types.eq);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsTryParseTypeParameters() {\n    if (this.isRelational(\"<\")) {\n      return this.tsParseTypeParameters();\n    }\n  }\n\n  tsParseTypeParameters() {\n    const node = this.startNode();\n\n    if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), false, true);\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsTryNextParseConstantContext() {\n    if (this.lookahead().type === types._const) {\n      this.next();\n      return this.tsParseTypeReference();\n    }\n\n    return null;\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === types.arrow;\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(types.parenL);\n    signature.parameters = this.tsParseBindingListForSignature();\n\n    if (returnTokenRequired) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n\n  tsParseBindingListForSignature() {\n    return this.parseBindingList(types.parenR, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(pattern.start, \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern,\" + `instead got ${pattern.type}`);\n      }\n\n      return pattern;\n    });\n  }\n\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(types.comma)) {\n      this.semicolon();\n    }\n  }\n\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(types.colon, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    return this.eat(types.name) && this.match(types.colon);\n  }\n\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n\n    this.expect(types.bracketL);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(types.bracketR);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(types.question)) node.optional = true;\n    const nodeAny = node;\n\n    if (!readonly && (this.match(types.parenL) || this.isRelational(\"<\"))) {\n      const method = nodeAny;\n      this.tsFillSignature(types.colon, method);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n\n  tsParseTypeMember() {\n    const node = this.startNode();\n\n    if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n\n    if (this.match(types._new)) {\n      const id = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n\n    const readonly = !!this.tsParseModifier([\"readonly\"]);\n    const idx = this.tsTryParseIndexSignature(node);\n\n    if (idx) {\n      if (readonly) node.readonly = true;\n      return idx;\n    }\n\n    this.parsePropertyName(node);\n    return this.tsParsePropertyOrMethodSignature(node, readonly);\n  }\n\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n\n  tsParseObjectTypeMembers() {\n    this.expect(types.braceL);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(types.braceR);\n    return members;\n  }\n\n  tsIsStartOfMappedType() {\n    this.next();\n\n    if (this.eat(types.plusMin)) {\n      return this.isContextual(\"readonly\");\n    }\n\n    if (this.isContextual(\"readonly\")) {\n      this.next();\n    }\n\n    if (!this.match(types.bracketL)) {\n      return false;\n    }\n\n    this.next();\n\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n\n    this.next();\n    return this.match(types._in);\n  }\n\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsExpectThenParseType(types._in);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(types.braceL);\n\n    if (this.match(types.plusMin)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(\"readonly\");\n    } else if (this.eatContextual(\"readonly\")) {\n      node.readonly = true;\n    }\n\n    this.expect(types.bracketL);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    this.expect(types.bracketR);\n\n    if (this.match(types.plusMin)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(types.question);\n    } else if (this.eat(types.question)) {\n      node.optional = true;\n    }\n\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach(elementNode => {\n      if (elementNode.type === \"TSOptionalType\") {\n        seenOptionalElement = true;\n      } else if (seenOptionalElement && elementNode.type !== \"TSRestType\") {\n        this.raise(elementNode.start, \"A required element cannot follow an optional element.\");\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n\n  tsParseTupleElementType() {\n    if (this.match(types.ellipsis)) {\n      const restNode = this.startNode();\n      this.next();\n      restNode.typeAnnotation = this.tsParseType();\n\n      if (this.match(types.comma) && this.lookaheadCharCode() !== 93) {\n        this.raiseRestNotLast(this.state.start);\n      }\n\n      return this.finishNode(restNode, \"TSRestType\");\n    }\n\n    const type = this.tsParseType();\n\n    if (this.eat(types.question)) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      return this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n\n    return type;\n  }\n\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(types.parenL);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n\n  tsParseFunctionOrConstructorType(type) {\n    const node = this.startNode();\n\n    if (type === \"TSConstructorType\") {\n      this.expect(types._new);\n    }\n\n    this.tsFillSignature(types.arrow, node);\n    return this.finishNode(node, type);\n  }\n\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n\n    node.literal = (() => {\n      switch (this.state.type) {\n        case types.num:\n        case types.string:\n        case types._true:\n        case types._false:\n          return this.parseExprAtom();\n\n        default:\n          throw this.unexpected();\n      }\n    })();\n\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    const templateNode = this.parseTemplate(false);\n\n    if (templateNode.expressions.length > 0) {\n      this.raise(templateNode.expressions[0].start, \"Template literal types cannot have any substitution\");\n    }\n\n    node.literal = templateNode;\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case types.name:\n      case types._void:\n      case types._null:\n        {\n          const type = this.match(types._void) ? \"TSVoidKeyword\" : this.match(types._null) ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n          if (type !== undefined && this.lookaheadCharCode() !== 46) {\n            const node = this.startNode();\n            this.next();\n            return this.finishNode(node, type);\n          }\n\n          return this.tsParseTypeReference();\n        }\n\n      case types.string:\n      case types.num:\n      case types._true:\n      case types._false:\n        return this.tsParseLiteralTypeNode();\n\n      case types.plusMin:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n\n          if (this.lookahead().type !== types.num) {\n            throw this.unexpected();\n          }\n\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n\n        break;\n\n      case types._this:\n        return this.tsParseThisTypeOrThisTypePredicate();\n\n      case types._typeof:\n        return this.tsParseTypeQuery();\n\n      case types._import:\n        return this.tsParseImportType();\n\n      case types.braceL:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n      case types.bracketL:\n        return this.tsParseTupleType();\n\n      case types.parenL:\n        return this.tsParseParenthesizedType();\n\n      case types.backQuote:\n        return this.tsParseTemplateLiteralType();\n    }\n\n    throw this.unexpected();\n  }\n\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n\n    while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {\n      if (this.match(types.bracketR)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n\n    return type;\n  }\n\n  tsParseTypeOperator(operator) {\n    const node = this.startNode();\n    this.expectContextual(operator);\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n\n      default:\n        this.raise(node.start, \"'readonly' type modifier is only permitted on array and tuple literal types.\");\n    }\n  }\n\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(\"infer\");\n    const typeParameter = this.startNode();\n    typeParameter.name = this.parseIdentifierName(typeParameter.start);\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n\n  tsParseTypeOperatorOrHigher() {\n    const operator = [\"keyof\", \"unique\", \"readonly\"].find(kw => this.isContextual(kw));\n    return operator ? this.tsParseTypeOperator(operator) : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n  }\n\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    this.eat(operator);\n    let type = parseConstituentType();\n\n    if (this.match(operator)) {\n      const types = [type];\n\n      while (this.eat(operator)) {\n        types.push(parseConstituentType());\n      }\n\n      const node = this.startNodeAtNode(type);\n      node.types = types;\n      type = this.finishNode(node, kind);\n    }\n\n    return type;\n  }\n\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);\n  }\n\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);\n  }\n\n  tsIsStartOfFunctionType() {\n    if (this.isRelational(\"<\")) {\n      return true;\n    }\n\n    return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n\n  tsSkipParameterStart() {\n    if (this.match(types.name) || this.match(types._this)) {\n      this.next();\n      return true;\n    }\n\n    if (this.match(types.braceL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.braceL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.braceR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    if (this.match(types.bracketL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.bracketL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.bracketR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n\n    if (this.match(types.parenR) || this.match(types.ellipsis)) {\n      return true;\n    }\n\n    if (this.tsSkipParameterStart()) {\n      if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {\n        return true;\n      }\n\n      if (this.match(types.parenR)) {\n        this.next();\n\n        if (this.match(types.arrow)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const asserts = this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n      if (asserts && this.match(types._this)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n\n        if (thisTypePredicate.type === \"TSThisType\") {\n          const node = this.startNodeAtNode(t);\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          thisTypePredicate.asserts = true;\n        }\n\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        const node = this.startNodeAtNode(t);\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      const node = this.startNodeAtNode(t);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;\n  }\n\n  tsTryParseTypeAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;\n  }\n\n  tsTryParseType() {\n    return this.tsEatThenParseType(types.colon);\n  }\n\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n\n  tsParseTypePredicateAsserts() {\n    if (!this.match(types.name) || this.state.value !== \"asserts\" || this.hasPrecedingLineBreak()) {\n      return false;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.next();\n\n    if (!this.match(types.name) && !this.match(types._this)) {\n      return false;\n    }\n\n    if (containsEsc) {\n      this.raise(this.state.lastTokStart, \"Escape sequence in keyword asserts\");\n    }\n\n    return true;\n  }\n\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(types.colon);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n\n    if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {\n      return type;\n    }\n\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsParseNonConditionalType();\n    this.expect(types.question);\n    node.trueType = this.tsParseType();\n    this.expect(types.colon);\n    node.falseType = this.tsParseType();\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n\n    if (this.match(types._new)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    }\n\n    return this.tsParseUnionTypeOrHigher();\n  }\n\n  tsParseTypeAssertion() {\n    const node = this.startNode();\n\n    const _const = this.tsTryNextParseConstantContext();\n\n    node.typeAnnotation = _const || this.tsNextThenParseType();\n    this.expectRelational(\">\");\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n\n  tsParseHeritageClause(descriptor) {\n    const originalStart = this.state.start;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n\n    if (!delimitedList.length) {\n      this.raise(originalStart, `'${descriptor}' list cannot be empty.`);\n    }\n\n    return delimitedList;\n  }\n\n  tsParseExpressionWithTypeArguments() {\n    const node = this.startNode();\n    node.expression = this.tsParseEntityName(false);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n  }\n\n  tsParseInterfaceDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, BIND_TS_INTERFACE, undefined, \"typescript interface declaration\");\n    node.typeParameters = this.tsTryParseTypeParameters();\n\n    if (this.eat(types._extends)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, BIND_TS_TYPE, undefined, \"typescript type alias\");\n    node.typeParameters = this.tsTryParseTypeParameters();\n    node.typeAnnotation = this.tsExpectThenParseType(types.eq);\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n\n    if (this.eat(types.eq)) {\n      node.initializer = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n\n  tsParseEnumDeclaration(node, isConst) {\n    if (isConst) node.const = true;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM, undefined, \"typescript enum declaration\");\n    this.expect(types.braceL);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.braceL);\n    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n\n    if (!nested) {\n      this.checkLVal(node.id, BIND_TS_NAMESPACE, null, \"module or namespace declaration\");\n    }\n\n    if (this.eat(types.dot)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      node.body = this.tsParseModuleBlock();\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(\"global\")) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(types.string)) {\n      node.id = this.parseExprAtom();\n    } else {\n      this.unexpected();\n    }\n\n    if (this.match(types.braceL)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      node.body = this.tsParseModuleBlock();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, BIND_LEXICAL, undefined, \"import equals declaration\");\n    this.expect(types.eq);\n    node.moduleReference = this.tsParseModuleReference();\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n\n  tsIsExternalModuleReference() {\n    return this.isContextual(\"require\") && this.lookaheadCharCode() === 40;\n  }\n\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(\"require\");\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      throw this.unexpected();\n    }\n\n    node.expression = this.parseExprAtom();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n\n    let starttype = this.state.type;\n    let kind;\n\n    if (this.isContextual(\"let\")) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case types._function:\n        return this.parseFunctionStatement(nany, false, true);\n\n      case types._class:\n        nany.declare = true;\n        return this.parseClass(nany, true, false);\n\n      case types._const:\n        if (this.match(types._const) && this.isLookaheadContextual(\"enum\")) {\n          this.expect(types._const);\n          this.expectContextual(\"enum\");\n          return this.tsParseEnumDeclaration(nany, true);\n        }\n\n      case types._var:\n        kind = kind || this.state.value;\n        return this.parseVarStatement(nany, kind);\n\n      case types.name:\n        {\n          const value = this.state.value;\n\n          if (value === \"global\") {\n            return this.tsParseAmbientExternalModuleDeclaration(nany);\n          } else {\n            return this.tsParseDeclaration(nany, value, true);\n          }\n        }\n    }\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n  }\n\n  tsParseExpressionStatement(node, expr) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n\n          break;\n        }\n\n      case \"global\":\n        if (this.match(types.braceL)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n\n        break;\n\n      default:\n        return this.tsParseDeclaration(node, expr.name, false);\n    }\n  }\n\n  tsParseDeclaration(node, value, next) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {\n          const cls = node;\n          cls.abstract = true;\n\n          if (next) {\n            this.next();\n\n            if (!this.match(types._class)) {\n              this.unexpected(null, types._class);\n            }\n          }\n\n          return this.parseClass(cls, true, false);\n        }\n\n        break;\n\n      case \"enum\":\n        if (next || this.match(types.name)) {\n          if (next) this.next();\n          return this.tsParseEnumDeclaration(node, false);\n        }\n\n        break;\n\n      case \"interface\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseInterfaceDeclaration(node);\n        }\n\n        break;\n\n      case \"module\":\n        if (next) this.next();\n\n        if (this.match(types.string)) {\n          return this.tsParseAmbientExternalModuleDeclaration(node);\n        } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"namespace\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"type\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n\n        break;\n    }\n  }\n\n  tsCheckLineTerminatorAndMatch(tokenType, next) {\n    return (next || this.match(tokenType)) && !this.isLineTerminator();\n  }\n\n  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n    if (!this.isRelational(\"<\")) {\n      return undefined;\n    }\n\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(types.arrow);\n      return node;\n    });\n\n    if (!res) {\n      return undefined;\n    }\n\n    return this.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expectRelational(\"<\");\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    this.state.exprAllowed = false;\n    this.expectRelational(\">\");\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n\n  tsIsDeclarationStart() {\n    if (this.match(types.name)) {\n      switch (this.state.value) {\n        case \"abstract\":\n        case \"declare\":\n        case \"enum\":\n        case \"interface\":\n        case \"module\":\n        case \"namespace\":\n        case \"type\":\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n\n    if (allowModifiers) {\n      accessibility = this.parseAccessModifier();\n      readonly = !!this.tsParseModifier([\"readonly\"]);\n    }\n\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (accessibility || readonly) {\n      const pp = this.startNodeAt(startPos, startLoc);\n\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(pp.start, \"A parameter property may not be declared using a binding pattern.\");\n      }\n\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n    }\n\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" ? \"TSDeclareMethod\" : undefined;\n\n    if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {\n      this.finishNode(node, bodilessType);\n      return;\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkLVal(node.id, BIND_TS_AMBIENT, null, \"function name\");\n    } else {\n      super.registerFunctionStatementId(...arguments);\n    }\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {\n      this.state.exprAllowed = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startPos, startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n\n    if (this.isRelational(\"<\")) {\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsync(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const typeArguments = this.tsParseTypeArguments();\n\n        if (typeArguments) {\n          if (!noCalls && this.eat(types.parenL)) {\n            node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n            node.typeParameters = typeArguments;\n            return this.finishCallExpression(node, state.optionalChainMember);\n          } else if (this.match(types.backQuote)) {\n            return this.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);\n          }\n        }\n\n        this.unexpected();\n      });\n      if (result) return result;\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n  }\n\n  parseNewArguments(node) {\n    if (this.isRelational(\"<\")) {\n      const typeParameters = this.tsTryParseAndCatch(() => {\n        const args = this.tsParseTypeArguments();\n        if (!this.match(types.parenL)) this.unexpected();\n        return args;\n      });\n\n      if (typeParameters) {\n        node.typeParameters = typeParameters;\n      }\n    }\n\n    super.parseNewArguments(node);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(\"as\")) {\n      const node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.expression = left;\n\n      const _const = this.tsTryNextParseConstantContext();\n\n      if (_const) {\n        node.typeAnnotation = _const;\n      } else {\n        node.typeAnnotation = this.tsNextThenParseType();\n      }\n\n      this.finishNode(node, \"TSAsExpression\");\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n\n    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}\n\n  checkDuplicateExports() {}\n\n  parseImport(node) {\n    if (this.match(types.name) && this.lookahead().type === types.eq) {\n      return this.tsParseImportEqualsDeclaration(node);\n    }\n\n    return super.parseImport(node);\n  }\n\n  parseExport(node) {\n    if (this.match(types._import)) {\n      this.expect(types._import);\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(types.eq)) {\n      const assign = node;\n      assign.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(\"as\")) {\n      const decl = node;\n      this.expectContextual(\"namespace\");\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      return super.parseExport(node);\n    }\n  }\n\n  isAbstractClass() {\n    return this.isContextual(\"abstract\") && this.lookahead().type === types._class;\n  }\n\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      this.parseClass(cls, true, true);\n      cls.abstract = true;\n      return cls;\n    }\n\n    if (this.state.value === \"interface\") {\n      const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);\n      if (result) return result;\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseStatementContent(context, topLevel) {\n    if (this.state.type === types._const) {\n      const ahead = this.lookahead();\n\n      if (ahead.type === types.name && ahead.value === \"enum\") {\n        const node = this.startNode();\n        this.expect(types._const);\n        this.expectContextual(\"enum\");\n        return this.tsParseEnumDeclaration(node, true);\n      }\n    }\n\n    return super.parseStatementContent(context, topLevel);\n  }\n\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n\n  parseClassMember(classBody, member, state, constructorAllowsSuper) {\n    const accessibility = this.parseAccessModifier();\n    if (accessibility) member.accessibility = accessibility;\n    super.parseClassMember(classBody, member, state, constructorAllowsSuper);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {\n    const modifiers = this.tsParseModifiers([\"abstract\", \"readonly\", \"declare\"]);\n    Object.assign(member, modifiers);\n    const idx = this.tsTryParseIndexSignature(member);\n\n    if (idx) {\n      classBody.body.push(idx);\n\n      if (modifiers.abstract) {\n        this.raise(member.start, \"Index signatures cannot have the 'abstract' modifier\");\n      }\n\n      if (isStatic) {\n        this.raise(member.start, \"Index signatures cannot have the 'static' modifier\");\n      }\n\n      if (member.accessibility) {\n        this.raise(member.start, `Index signatures cannot have an accessibility modifier ('${member.accessibility}')`);\n      }\n\n      return;\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(types.question);\n    if (optional) methodOrProp.optional = true;\n\n    if (methodOrProp.readonly && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, \"Class methods cannot have the 'readonly' modifier\");\n    }\n\n    if (methodOrProp.declare && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, \"Class methods cannot have the 'declare' modifier\");\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n    return decl || super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (!refNeedsArrowPos || !this.match(types.question)) {\n      return super.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n    }\n\n    const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));\n\n    if (!result.node) {\n      refNeedsArrowPos.start = result.error.pos || this.state.start;\n      return expr;\n    }\n\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(types.question)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(types.colon)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  parseExportDeclaration(node) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(\"declare\");\n    let declaration;\n\n    if (this.match(types.name)) {\n      declaration = this.tsTryParseExportDeclaration();\n    }\n\n    if (!declaration) {\n      declaration = super.parseExportDeclaration(node);\n    }\n\n    if (declaration && isDeclare) {\n      this.resetStartLocation(declaration, startPos, startLoc);\n      declaration.declare = true;\n    }\n\n    return declaration;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\n      return;\n    }\n\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(types.bang)) {\n      node.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n\n    if (node.declare && this.match(types.equal)) {\n      this.raise(this.state.start, \"'declare' class fields cannot have an initializer\");\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(node.start, \"Private elements cannot have the 'abstract' modifier.\");\n    }\n\n    if (node.accessibility) {\n      this.raise(node.start, `Private elements cannot have an accessibility modifier ('${node.accessibility}')`);\n    }\n\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.tsParseTypeArguments();\n    }\n\n    if (this.eatContextual(\"implements\")) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n\n  parseObjPropValue(prop, ...args) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    super.parseObjPropValue(prop, ...args);\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (decl.id.type === \"Identifier\" && this.eat(types.bang)) {\n      decl.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  parseMaybeAssign(...args) {\n    let state;\n    let jsx;\n    let typeCast;\n\n    if (this.match(types.jsxTagStart)) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types$1.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types$1.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (!(jsx && jsx.error) && !this.isRelational(\"<\")) {\n      return super.parseMaybeAssign(...args);\n    }\n\n    let typeParameters;\n    state = state || this.state.clone();\n    const arrow = this.tryParse(abort => {\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(...args);\n\n      if (expr.type !== \"ArrowFunctionExpression\" || expr.extra && expr.extra.parenthesized) {\n        abort();\n      }\n\n      if (typeParameters && typeParameters.params.length !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) return arrow.node;\n\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n\n    if (jsx && jsx.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n\n    if (arrow.node) {\n      this.state = arrow.failState;\n      return arrow.node;\n    }\n\n    if (typeCast && typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n\n    if (jsx && jsx.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if (typeCast && typeCast.thrown) throw typeCast.error;\n    throw jsx && jsx.error || arrow.error || typeCast && typeCast.error;\n  }\n\n  parseMaybeUnary(refShorthandDefaultPos) {\n    if (!this.hasPlugin(\"jsx\") && this.isRelational(\"<\")) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refShorthandDefaultPos);\n    }\n  }\n\n  parseArrow(node) {\n    if (this.match(types.colon)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n        if (this.canInsertSemicolon() || !this.match(types.arrow)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(types.question)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(param.start, \"A binding pattern parameter cannot be optional in an implementation signature.\");\n      }\n\n      param.optional = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  toAssignable(node, isBinding, contextDescription) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return super.toAssignable(this.typeCastToParameter(node), isBinding, contextDescription);\n\n      case \"TSParameterProperty\":\n        return super.toAssignable(node, isBinding, contextDescription);\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        node.expression = this.toAssignable(node.expression, isBinding, contextDescription);\n        return node;\n\n      default:\n        return super.toAssignable(node, isBinding, contextDescription);\n    }\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {\n    switch (expr.type) {\n      case \"TSTypeCastExpression\":\n        return;\n\n      case \"TSParameterProperty\":\n        this.checkLVal(expr.parameter, bindingType, checkClashes, \"parameter property\");\n        return;\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);\n        return;\n\n      default:\n        super.checkLVal(expr, bindingType, checkClashes, contextDescription);\n        return;\n    }\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types._this:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsParseTypeArguments();\n\n      if (this.match(types.parenL)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n\n      this.unexpected(this.state.start, types.parenL);\n    }\n\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();\n  }\n\n  parseMaybeDefault(...args) {\n    const node = super.parseMaybeDefault(...args);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, \"Type annotations must come before default assignments, \" + \"e.g. instead of `age = 25: number` use `age: number = 25`\");\n    }\n\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(types.relational, 1);\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  toAssignableList(exprList, isBinding) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if (!expr) continue;\n\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          exprList[i] = this.typeCastToParameter(expr);\n          break;\n\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n          if (!isBinding) {\n            exprList[i] = this.typeCastToParameter(expr);\n          } else {\n            this.raise(expr.start, \"Unexpected type cast in parameter position.\");\n          }\n\n          break;\n      }\n    }\n\n    return super.toAssignableList(...arguments);\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  toReferencedList(exprList, isInParens) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if (expr && expr._exprListItem && expr.type === \"TsTypeCastExpression\") {\n        this.raise(expr.start, \"Did not expect a type annotation here.\");\n      }\n    }\n\n    return exprList;\n  }\n\n  shouldParseArrow() {\n    return this.match(types.colon) || super.shouldParseArrow();\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.colon) || super.shouldParseAsyncArrow();\n  }\n\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const firstParam = method.params[0];\n    const hasContextParam = firstParam && firstParam.type === \"Identifier\" && firstParam.name === \"this\";\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n\n});\n\ntypes.placeholder = new TokenType(\"%%\", {\n  startsExpr: true\n});\nvar placeholders = (superClass => class extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(types.placeholder)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      this.expect(types.placeholder);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(types.placeholder, 2);\n    }\n\n    return super.getTokenFromCode(...arguments);\n  }\n\n  parseExprAtom() {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments);\n  }\n\n  parseIdentifier() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(...arguments);\n  }\n\n  checkReservedWord(word) {\n    if (word !== undefined) super.checkReservedWord(...arguments);\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments);\n  }\n\n  checkLVal(expr) {\n    if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\n  }\n\n  toAssignable(node) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n      return node;\n    }\n\n    return super.toAssignable(...arguments);\n  }\n\n  verifyBreakContinue(node) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(...arguments);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(...arguments);\n    }\n\n    if (this.match(types.colon)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = this.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n\n  parseBlock() {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(...arguments);\n  }\n\n  parseFunctionId() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(...arguments);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    this.takeDecorators(node);\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n\n    if (placeholder) {\n      if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        this.unexpected(null, \"A class name is required\");\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n\n    this.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || this.parseClassBody(!!node.superClass);\n    return this.finishNode(node, type);\n  }\n\n  parseExport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(...arguments);\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n\n    return super.maybeParseExportDefaultSpecifier(...arguments);\n  }\n\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n\n    if (specifiers && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(...arguments);\n    node.specifiers = [];\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    this.finishNode(specifier, \"ImportDefaultSpecifier\");\n    node.specifiers.push(specifier);\n\n    if (this.eat(types.comma)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n\n    this.expectContextual(\"from\");\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource(...arguments);\n  }\n\n});\n\nvar v8intrinsic = (superClass => class extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(types.modulo)) {\n      const v8IntrinsicStart = this.state.start;\n      const node = this.startNode();\n      this.eat(types.modulo);\n\n      if (this.match(types.name)) {\n        const name = this.parseIdentifierName(this.state.start);\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n\n        if (this.match(types.parenL)) {\n          return identifier;\n        }\n      }\n\n      this.unexpected(v8IntrinsicStart);\n    }\n  }\n\n  parseExprAtom() {\n    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n  }\n\n});\n\nfunction hasPlugin(plugins, name) {\n  return plugins.some(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"smart\", \"fsharp\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you are migrating from\" + \" Babylon/Babel 6 or want to use the old decorators proposal, you\" + \" should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, \"pipelineOperator\", \"proposal\"))) {\n    throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \" + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(\", \"));\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false\n};\nfunction getOptions(opts) {\n  const options = {};\n\n  for (let _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {\n    const key = _Object$keys[_i];\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nclass Position {\n  constructor(line, col) {\n    this.line = line;\n    this.column = col;\n  }\n\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n}\nfunction getLineInfo(input, offset) {\n  let line = 1;\n  let lineStart = 0;\n  let match;\n  lineBreakG.lastIndex = 0;\n\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\n    line++;\n    lineStart = lineBreakG.lastIndex;\n  }\n\n  return new Position(line, offset - lineStart);\n}\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n\n  hasPlugin(name) {\n    return this.plugins.has(name);\n  }\n\n  getPluginOption(plugin, name) {\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\n  }\n\n}\n\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.trailingComments.push(comment);\n    this.state.leadingComments.push(comment);\n  }\n\n  adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {\n    if (this.state.leadingComments.length === 0) {\n      return;\n    }\n\n    let lastElement = null;\n    let i = elements.length;\n\n    while (lastElement === null && i > 0) {\n      lastElement = elements[--i];\n    }\n\n    if (lastElement === null) {\n      return;\n    }\n\n    for (let j = 0; j < this.state.leadingComments.length; j++) {\n      if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n        this.state.leadingComments.splice(j, 1);\n        j--;\n      }\n    }\n\n    const newTrailingComments = [];\n\n    for (let i = 0; i < this.state.leadingComments.length; i++) {\n      const leadingComment = this.state.leadingComments[i];\n\n      if (leadingComment.end < node.end) {\n        newTrailingComments.push(leadingComment);\n\n        if (!takeAllComments) {\n          this.state.leadingComments.splice(i, 1);\n          i--;\n        }\n      } else {\n        if (node.trailingComments === undefined) {\n          node.trailingComments = [];\n        }\n\n        node.trailingComments.push(leadingComment);\n      }\n    }\n\n    if (takeAllComments) this.state.leadingComments = [];\n\n    if (newTrailingComments.length > 0) {\n      lastElement.trailingComments = newTrailingComments;\n    } else if (lastElement.trailingComments !== undefined) {\n      lastElement.trailingComments = [];\n    }\n  }\n\n  processComment(node) {\n    if (node.type === \"Program\" && node.body.length > 0) return;\n    const stack = this.state.commentStack;\n    let firstChild, lastChild, trailingComments, i, j;\n\n    if (this.state.trailingComments.length > 0) {\n      if (this.state.trailingComments[0].start >= node.end) {\n        trailingComments = this.state.trailingComments;\n        this.state.trailingComments = [];\n      } else {\n        this.state.trailingComments.length = 0;\n      }\n    } else if (stack.length > 0) {\n      const lastInStack = last(stack);\n\n      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n        trailingComments = lastInStack.trailingComments;\n        delete lastInStack.trailingComments;\n      }\n    }\n\n    if (stack.length > 0 && last(stack).start >= node.start) {\n      firstChild = stack.pop();\n    }\n\n    while (stack.length > 0 && last(stack).start >= node.start) {\n      lastChild = stack.pop();\n    }\n\n    if (!lastChild && firstChild) lastChild = firstChild;\n\n    if (firstChild) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties);\n          break;\n\n        case \"ObjectPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties, true);\n          break;\n\n        case \"CallExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.arguments);\n          break;\n\n        case \"ArrayExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements);\n          break;\n\n        case \"ArrayPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements, true);\n          break;\n      }\n    } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === \"ImportSpecifier\" && node.type !== \"ImportSpecifier\" || this.state.commentPreviousNode.type === \"ExportSpecifier\" && node.type !== \"ExportSpecifier\")) {\n      this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode], true);\n    }\n\n    if (lastChild) {\n      if (lastChild.leadingComments) {\n        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        } else {\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n            if (lastChild.leadingComments[i].end <= node.start) {\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n              break;\n            }\n          }\n        }\n      }\n    } else if (this.state.leadingComments.length > 0) {\n      if (last(this.state.leadingComments).end <= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n        }\n\n        if (this.state.leadingComments.length > 0) {\n          node.leadingComments = this.state.leadingComments;\n          this.state.leadingComments = [];\n        }\n      } else {\n        for (i = 0; i < this.state.leadingComments.length; i++) {\n          if (this.state.leadingComments[i].end > node.start) {\n            break;\n          }\n        }\n\n        const leadingComments = this.state.leadingComments.slice(0, i);\n\n        if (leadingComments.length) {\n          node.leadingComments = leadingComments;\n        }\n\n        trailingComments = this.state.leadingComments.slice(i);\n\n        if (trailingComments.length === 0) {\n          trailingComments = null;\n        }\n      }\n    }\n\n    this.state.commentPreviousNode = node;\n\n    if (trailingComments) {\n      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n        node.innerComments = trailingComments;\n      } else {\n        node.trailingComments = trailingComments;\n      }\n    }\n\n    stack.push(node);\n  }\n\n}\n\nclass LocationParser extends CommentsParser {\n  getLocationForPosition(pos) {\n    let loc;\n    if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);\n    return loc;\n  }\n\n  raise(pos, message, {\n    missingPluginNames,\n    code\n  } = {}) {\n    const loc = this.getLocationForPosition(pos);\n    message += ` (${loc.line}:${loc.column})`;\n    const err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n\n    if (missingPluginNames) {\n      err.missingPlugin = missingPluginNames;\n    }\n\n    if (code !== undefined) {\n      err.code = code;\n    }\n\n    if (this.options.errorRecovery) {\n      if (!this.isLookahead) this.state.errors.push(err);\n      return err;\n    } else {\n      throw err;\n    }\n  }\n\n}\n\nclass State {\n  constructor() {\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.inParameters = false;\n    this.maybeInArrowParameters = false;\n    this.inPipeline = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.inPropertyName = false;\n    this.inClassProperty = false;\n    this.hasFlowComment = false;\n    this.isIterator = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.classLevel = 0;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.yieldPos = -1;\n    this.awaitPos = -1;\n    this.tokens = [];\n    this.comments = [];\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = [];\n    this.commentPreviousNode = null;\n    this.pos = 0;\n    this.lineStart = 0;\n    this.type = types.eof;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.lastTokEnd = 0;\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n    this.containsEsc = false;\n    this.containsOctal = false;\n    this.octalPosition = null;\n    this.exportedIdentifiers = [];\n    this.invalidTemplateEscapePosition = null;\n  }\n\n  init(options) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n    this.curLine = options.startLine;\n    this.startLoc = this.endLoc = this.curPosition();\n  }\n\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n\n    return state;\n  }\n\n}\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst VALID_REGEX_FLAGS = new Set([\"g\", \"m\", \"s\", \"i\", \"y\", \"u\"]);\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n  hex: [46, 88, 95, 120]\n};\nconst allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [48, 49];\nallowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];\nallowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];\nallowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n}\nclass Tokenizer extends LocationParser {\n  constructor(options, input) {\n    super();\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  next() {\n    if (!this.isLookahead) {\n      this.checkKeywordEscapes();\n\n      if (this.options.tokens) {\n        this.state.tokens.push(new Token(this.state));\n      }\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = old.clone(true);\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart() {\n    const thisTokEnd = this.state.pos;\n    skipWhiteSpace.lastIndex = thisTokEnd;\n    const skip = skipWhiteSpace.exec(this.input);\n    return thisTokEnd + skip[0].length;\n  }\n\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (!this.match(types.num) && !this.match(types.string)) return;\n    this.state.pos = this.state.start;\n\n    while (this.state.pos < this.state.lineStart) {\n      this.state.lineStart = this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1;\n      --this.state.curLine;\n    }\n\n    this.nextToken();\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    const curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n    this.state.containsOctal = false;\n    this.state.octalPosition = null;\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.length) {\n      this.finishToken(types.eof);\n      return;\n    }\n\n    if (curContext.override) {\n      curContext.override(this);\n    } else {\n      this.getTokenFromCode(this.input.codePointAt(this.state.pos));\n    }\n  }\n\n  pushComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n    if (this.options.tokens) this.state.tokens.push(comment);\n    this.state.comments.push(comment);\n    this.addComment(comment);\n  }\n\n  skipBlockComment() {\n    const startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", this.state.pos + 2);\n    if (end === -1) throw this.raise(start, \"Unterminated comment\");\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    let match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipSpace() {\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) this.updateContext(prevType);\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.input.charCodeAt(nextPos);\n\n    if (next >= 48 && next <= 57) {\n      throw this.raise(this.state.pos, \"Unexpected digit after hash token\");\n    }\n\n    if ((this.hasPlugin(\"classPrivateProperties\") || this.hasPlugin(\"classPrivateMethods\")) && this.state.classLevel > 0) {\n      ++this.state.pos;\n      this.finishToken(types.hash);\n      return;\n    } else if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      this.finishOp(types.hash, 1);\n    } else {\n      throw this.raise(this.state.pos, \"Unexpected character '#'\");\n    }\n  }\n\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.dot);\n    }\n  }\n\n  readToken_slash() {\n    if (this.state.exprAllowed && !this.state.inType) {\n      ++this.state.pos;\n      this.readRegexp();\n      return;\n    }\n\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.slash, 1);\n    }\n  }\n\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    let ch = this.input.charCodeAt(this.state.pos);\n    if (ch !== 33) return false;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(types.interpreterDirective, value);\n    return true;\n  }\n\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? types.star : types.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    const exprAllowed = this.state.exprAllowed;\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61 && !exprAllowed) {\n      width++;\n      type = types.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n      }\n\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(types.pipeline, 2);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  }\n\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos)))) {\n        this.skipLineComment(3);\n        this.skipSpace();\n        this.nextToken();\n        return;\n      }\n\n      this.finishOp(types.incDec, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.plusMin, 1);\n    }\n  }\n\n  readToken_lt_gt(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    let size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.state.pos + size) === 61) {\n        this.finishOp(types.assign, size + 1);\n        return;\n      }\n\n      this.finishOp(types.bitShift, size);\n      return;\n    }\n\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      this.skipLineComment(4);\n      this.skipSpace();\n      this.nextToken();\n      return;\n    }\n\n    if (next === 61) {\n      size = 2;\n    }\n\n    this.finishOp(types.relational, size);\n  }\n\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(types.arrow);\n      return;\n    }\n\n    this.finishOp(code === 61 ? types.eq : types.bang, 1);\n  }\n\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63 && !this.state.inType) {\n      if (next2 === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(types.nullishCoalescing, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(types.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.question);\n    }\n  }\n\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(types.parenL);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(types.parenR);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(types.semi);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(types.comma);\n        return;\n\n      case 91:\n        ++this.state.pos;\n        this.finishToken(types.bracketL);\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(types.bracketR);\n        return;\n\n      case 123:\n        ++this.state.pos;\n        this.finishToken(types.braceL);\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(types.braceR);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.colon);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 96:\n        ++this.state.pos;\n        this.finishToken(types.backQuote);\n        return;\n\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n      case 62:\n        this.readToken_lt_gt(code);\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(types.tilde, 1);\n        return;\n\n      case 64:\n        ++this.state.pos;\n        this.finishToken(types.at);\n        return;\n\n      case 35:\n        this.readToken_numberSign();\n        return;\n\n      case 92:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord();\n          return;\n        }\n\n    }\n\n    throw this.raise(this.state.pos, `Unexpected character '${String.fromCodePoint(code)}'`);\n  }\n\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp() {\n    const start = this.state.pos;\n    let escaped, inClass;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(start, \"Unterminated regular expression\");\n      }\n\n      const ch = this.input.charAt(this.state.pos);\n\n      if (lineBreak.test(ch)) {\n        throw this.raise(start, \"Unterminated regular expression\");\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n\n        escaped = ch === \"\\\\\";\n      }\n\n      ++this.state.pos;\n    }\n\n    const content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n    let mods = \"\";\n\n    while (this.state.pos < this.length) {\n      const char = this.input[this.state.pos];\n      const charCode = this.input.codePointAt(this.state.pos);\n\n      if (VALID_REGEX_FLAGS.has(char)) {\n        if (mods.indexOf(char) > -1) {\n          this.raise(this.state.pos + 1, \"Duplicate regular expression flag\");\n        }\n      } else if (isIdentifierChar(charCode) || charCode === 92) {\n        this.raise(this.state.pos + 1, \"Invalid regular expression flag\");\n      } else {\n        break;\n      }\n\n      ++this.state.pos;\n      mods += char;\n    }\n\n    this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen, allowNumSeparator = true) {\n    const start = this.state.pos;\n    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (this.hasPlugin(\"numericSeparator\")) {\n        if (code === 95) {\n          const prev = this.input.charCodeAt(this.state.pos - 1);\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (allowedSiblings.indexOf(next) === -1) {\n            this.raise(this.state.pos, \"A numeric separator is only allowed between two digits\");\n          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {\n            this.raise(this.state.pos, \"A numeric separator is only allowed between two digits\");\n          }\n\n          if (!allowNumSeparator) {\n            this.raise(this.state.pos, \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\");\n          }\n\n          ++this.state.pos;\n          continue;\n        }\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } else if (code >= 65) {\n        val = code - 65 + 10;\n      } else if (_isDigit(code)) {\n        val = code - 48;\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) {\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(this.state.start + i + 2, \"Expected number in radix \" + radix);\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.state.start + 2, \"Expected number in radix \" + radix);\n    }\n\n    if (this.hasPlugin(\"bigInt\")) {\n      if (this.input.charCodeAt(this.state.pos) === 110) {\n        ++this.state.pos;\n        isBigInt = true;\n      }\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, \"Identifier directly after number\");\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    this.finishToken(types.num, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    let isFloat = false;\n    let isBigInt = false;\n    let isNonOctalDecimalInt = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, \"Invalid number\");\n    }\n\n    let octal = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (octal) {\n      if (this.state.strict) {\n        this.raise(start, \"Legacy octal literals are not allowed in strict mode\");\n      }\n\n      if (/[89]/.test(this.input.slice(start, this.state.pos))) {\n        octal = false;\n        isNonOctalDecimalInt = true;\n      }\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !octal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !octal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (this.hasPlugin(\"numericSeparator\") && (octal || isNonOctalDecimalInt)) {\n      const underscorePos = this.input.slice(start, this.state.pos).indexOf(\"_\");\n\n      if (underscorePos > 0) {\n        this.raise(underscorePos + start, \"Numeric separator can not be used after leading 0\");\n      }\n    }\n\n    if (this.hasPlugin(\"bigInt\")) {\n      if (next === 110) {\n        if (isFloat || octal || isNonOctalDecimalInt) {\n          this.raise(start, \"Invalid BigIntLiteral\");\n        }\n\n        ++this.state.pos;\n        isBigInt = true;\n      }\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, \"Identifier directly after number\");\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    const val = octal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(types.num, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === 123) {\n      const codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, true, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code === null) {\n        --this.state.invalidTemplateEscapePosition;\n      } else if (code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, \"Code point out of bounds\");\n        } else {\n          this.state.invalidTemplateEscapePosition = codePos - 2;\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n\n    return code;\n  }\n\n  readString(quote) {\n    let out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, \"Unterminated string constant\");\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (ch === 8232 || ch === 8233) {\n        ++this.state.pos;\n        ++this.state.curLine;\n      } else if (isNewLine(ch)) {\n        throw this.raise(this.state.start, \"Unterminated string constant\");\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(types.string, out);\n  }\n\n  readTmplToken() {\n    let out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, \"Unterminated template\");\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            this.finishToken(types.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(types.backQuote);\n            return;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(types.template, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) {\n              ++this.state.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  readEscapedChar(inTemplate) {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n\n      case 114:\n        return \"\\r\";\n\n      case 120:\n        {\n          const code = this.readHexChar(2, false, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          const code = this.readCodePoint(throwOnInvalid);\n          return code === null ? null : String.fromCodePoint(code);\n        }\n\n      case 116:\n        return \"\\t\";\n\n      case 98:\n        return \"\\b\";\n\n      case 118:\n        return \"\\u000b\";\n\n      case 102:\n        return \"\\f\";\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n        }\n\n      case 10:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n\n      case 8232:\n      case 8233:\n        return \"\";\n\n      case 56:\n      case 57:\n        if (inTemplate) {\n          const codePos = this.state.pos - 1;\n          this.state.invalidTemplateEscapePosition = codePos;\n          return null;\n        }\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          const codePos = this.state.pos - 1;\n          let octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];\n          let octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n\n          if (octalStr !== \"0\" || next === 56 || next === 57) {\n            if (inTemplate) {\n              this.state.invalidTemplateEscapePosition = codePos;\n              return null;\n            } else if (this.state.strict) {\n              this.raise(codePos, \"Octal literal in strict mode\");\n            } else if (!this.state.containsOctal) {\n              this.state.containsOctal = true;\n              this.state.octalPosition = codePos;\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  readHexChar(len, forceLen, throwOnInvalid) {\n    const codePos = this.state.pos;\n    const n = this.readInt(16, len, forceLen, false);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, \"Bad character escape sequence\");\n      } else {\n        this.state.pos = codePos - 1;\n        this.state.invalidTemplateEscapePosition = codePos - 1;\n      }\n    }\n\n    return n;\n  }\n\n  readWord1() {\n    let word = \"\";\n    this.state.containsEsc = false;\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    while (this.state.pos < this.length) {\n      const ch = this.input.codePointAt(this.state.pos);\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (this.state.isIterator && ch === 64) {\n        ++this.state.pos;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.pos;\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(this.state.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(escStart, \"Invalid Unicode escape\");\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  isIterator(word) {\n    return word === \"@@iterator\" || word === \"@@asyncIterator\";\n  }\n\n  readWord() {\n    const word = this.readWord1();\n    const type = keywords.get(word) || types.name;\n\n    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {\n      this.raise(this.state.pos, `Invalid identifier ${word}`);\n    }\n\n    this.finishToken(type, word);\n  }\n\n  checkKeywordEscapes() {\n    const kw = this.state.type.keyword;\n\n    if (kw && this.state.containsEsc) {\n      this.raise(this.state.start, `Escape sequence in keyword ${kw}`);\n    }\n  }\n\n  braceIsBlock(prevType) {\n    const parent = this.curContext();\n\n    if (parent === types$1.functionExpression || parent === types$1.functionStatement) {\n      return true;\n    }\n\n    if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {\n      return !parent.isExpr;\n    }\n\n    if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {\n      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return parent === types$1.braceStatement;\n    }\n\n    if (prevType === types._var || prevType === types._const || prevType === types.name) {\n      return false;\n    }\n\n    if (prevType === types.relational) {\n      return true;\n    }\n\n    return !this.state.exprAllowed;\n  }\n\n  updateContext(prevType) {\n    const type = this.state.type;\n    let update;\n\n    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  }\n\n}\n\nconst literal = /^('|\")((?:\\\\?.)*?)\\1/;\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, val) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    extra[key] = val;\n  }\n\n  isRelational(op) {\n    return this.match(types.relational) && this.state.value === op;\n  }\n\n  isLookaheadRelational(op) {\n    const next = this.nextTokenStart();\n\n    if (this.input.charAt(next) === op) {\n      if (next + 1 === this.input.length) {\n        return true;\n      }\n\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== op.charCodeAt(0) && afterNext !== 61;\n    }\n\n    return false;\n  }\n\n  expectRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, types.relational);\n    }\n  }\n\n  eatRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  isContextual(name) {\n    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));\n  }\n\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(name) {\n    return this.isContextual(name) && this.eat(types.name);\n  }\n\n  expectContextual(name, message) {\n    if (!this.eatContextual(name)) this.unexpected(null, message);\n  }\n\n  canInsertSemicolon() {\n    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();\n  }\n\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n  }\n\n  isLineTerminator() {\n    return this.eat(types.semi) || this.canInsertSemicolon();\n  }\n\n  semicolon() {\n    if (!this.isLineTerminator()) this.unexpected(null, types.semi);\n  }\n\n  expect(type, pos) {\n    this.eat(type) || this.unexpected(pos, type);\n  }\n\n  assertNoSpace(message = \"Unexpected space.\") {\n    if (this.state.start > this.state.lastTokEnd) {\n      this.raise(this.state.lastTokEnd, message);\n    }\n  }\n\n  unexpected(pos, messageOrType = \"Unexpected token\") {\n    if (typeof messageOrType !== \"string\") {\n      messageOrType = `Unexpected token, expected \"${messageOrType.label}\"`;\n    }\n\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n  }\n\n  expectPlugin(name, pos) {\n    if (!this.hasPlugin(name)) {\n      throw this.raise(pos != null ? pos : this.state.start, `This experimental syntax requires enabling the parser plugin: '${name}'`, {\n        missingPluginNames: [name]\n      });\n    }\n\n    return true;\n  }\n\n  expectOnePlugin(names, pos) {\n    if (!names.some(n => this.hasPlugin(n))) {\n      throw this.raise(pos != null ? pos : this.state.start, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\", \")}'`, {\n        missingPluginNames: names\n      });\n    }\n  }\n\n  checkYieldAwaitInDefaultParams() {\n    if (this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos)) {\n      this.raise(this.state.yieldPos, \"Yield cannot be used as name inside a generator function\");\n    }\n\n    if (this.state.awaitPos !== -1) {\n      this.raise(this.state.awaitPos, \"Await cannot be used as name inside an async function\");\n    }\n  }\n\n  strictDirective(start) {\n    for (;;) {\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      const match = literal.exec(this.input.slice(start));\n      if (!match) break;\n      if (match[2] === \"use strict\") return true;\n      start += match[0].length;\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n\n      if (this.input[start] === \";\") {\n        start++;\n      }\n    }\n\n    return false;\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n\n      throw error;\n    }\n  }\n\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser && parser.options.ranges) this.range = [pos, 0];\n    if (parser && parser.filename) this.loc.filename = parser.filename;\n  }\n\n  __clone() {\n    const newNode = new Node();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  }\n\n}\n\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, pos, loc) {\n    if ( node.end > 0) {\n      throw new Error(\"Do not call finishNode*() twice on the same node.\" + \" Instead use resetEndLocation() or change type directly.\");\n    }\n\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {\n    node.end = end;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = end;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n\n}\n\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\n\nclass LValParser extends NodeUtils {\n  toAssignable(node, isBinding, contextDescription) {\n    var _node$extra3;\n\n    if (node) {\n      var _node$extra;\n\n      if (this.options.createParenthesizedExpressions && node.type === \"ParenthesizedExpression\" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {\n        const parenthesized = unwrapParenthesizedExpression(node);\n\n        if (parenthesized.type !== \"Identifier\" && parenthesized.type !== \"MemberExpression\") {\n          this.raise(node.start, \"Invalid parenthesized assignment pattern\");\n        }\n      }\n\n      switch (node.type) {\n        case \"Identifier\":\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"AssignmentPattern\":\n          break;\n\n        case \"ObjectExpression\":\n          node.type = \"ObjectPattern\";\n\n          for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n            var _node$extra2;\n\n            const prop = node.properties[i];\n            const isLast = i === last;\n            this.toAssignableObjectExpressionProp(prop, isBinding, isLast);\n\n            if (isLast && prop.type === \"RestElement\" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {\n              this.raiseRestNotLast(node.extra.trailingComma);\n            }\n          }\n\n          break;\n\n        case \"ObjectProperty\":\n          this.toAssignable(node.value, isBinding, contextDescription);\n          break;\n\n        case \"SpreadElement\":\n          {\n            this.checkToRestConversion(node);\n            node.type = \"RestElement\";\n            const arg = node.argument;\n            this.toAssignable(arg, isBinding, contextDescription);\n            break;\n          }\n\n        case \"ArrayExpression\":\n          node.type = \"ArrayPattern\";\n          this.toAssignableList(node.elements, isBinding, contextDescription, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma);\n          break;\n\n        case \"AssignmentExpression\":\n          if (node.operator !== \"=\") {\n            this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n          }\n\n          node.type = \"AssignmentPattern\";\n          delete node.operator;\n          this.toAssignable(node.left, isBinding, contextDescription);\n          break;\n\n        case \"ParenthesizedExpression\":\n          node.expression = this.toAssignable(node.expression, isBinding, contextDescription);\n          break;\n      }\n    }\n\n    return node;\n  }\n\n  toAssignableObjectExpressionProp(prop, isBinding, isLast) {\n    if (prop.type === \"ObjectMethod\") {\n      const error = prop.kind === \"get\" || prop.kind === \"set\" ? \"Object pattern can't contain getter or setter\" : \"Object pattern can't contain methods\";\n      this.raise(prop.key.start, error);\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raiseRestNotLast(prop.start);\n    } else {\n      this.toAssignable(prop, isBinding, \"object destructuring pattern\");\n    }\n  }\n\n  toAssignableList(exprList, isBinding, contextDescription, trailingCommaPos) {\n    let end = exprList.length;\n\n    if (end) {\n      const last = exprList[end - 1];\n\n      if (last && last.type === \"RestElement\") {\n        --end;\n      } else if (last && last.type === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        const arg = last.argument;\n        this.toAssignable(arg, isBinding, contextDescription);\n\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\" && arg.type !== \"ObjectPattern\") {\n          this.unexpected(arg.start);\n        }\n\n        if (trailingCommaPos) {\n          this.raiseTrailingCommaAfterRest(trailingCommaPos);\n        }\n\n        --end;\n      }\n    }\n\n    for (let i = 0; i < end; i++) {\n      const elt = exprList[i];\n\n      if (elt) {\n        this.toAssignable(elt, isBinding, contextDescription);\n\n        if (elt.type === \"RestElement\") {\n          this.raiseRestNotLast(elt.start);\n        }\n      }\n    }\n\n    return exprList;\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (let _i = 0; _i < exprList.length; _i++) {\n      const expr = exprList[_i];\n\n      if (expr && expr.type === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refShorthandDefaultPos, refNeedsArrowPos) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos, undefined, refNeedsArrowPos);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types.bracketL:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(types.bracketR, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case types.braceL:\n        return this.parseObj(true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n      }\n\n      if (allowEmpty && this.match(types.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(types.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        this.checkCommaAfterRest(closeCharCode);\n        this.expect(close);\n        break;\n      } else {\n        const decorators = [];\n\n        if (this.match(types.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(this.state.start, \"Stage 2 decorators cannot be used to decorate parameters\");\n        }\n\n        while (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    startLoc = startLoc || this.state.startLoc;\n    startPos = startPos || this.state.start;\n    left = left || this.parseBindingAtom();\n    if (!this.eat(types.eq)) return left;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding, strictModeChanged = false) {\n    switch (expr.type) {\n      case \"Identifier\":\n        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name))) {\n          this.raise(expr.start, `${bindingType === BIND_NONE ? \"Assigning to\" : \"Binding\"} '${expr.name}' in strict mode`);\n        }\n\n        if (checkClashes) {\n          const key = `_${expr.name}`;\n\n          if (checkClashes[key]) {\n            this.raise(expr.start, \"Argument name clash\");\n          } else {\n            checkClashes[key] = true;\n          }\n        }\n\n        if (disallowLetBinding && expr.name === \"let\") {\n          this.raise(expr.start, \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\");\n        }\n\n        if (!(bindingType & BIND_NONE)) {\n          this.scope.declareName(expr.name, bindingType, expr.start);\n        }\n\n        break;\n\n      case \"MemberExpression\":\n        if (bindingType !== BIND_NONE) {\n          this.raise(expr.start, \"Binding member expression\");\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n        for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {\n          let prop = _expr$properties[_i2];\n          if (prop.type === \"ObjectProperty\") prop = prop.value;else if (prop.type === \"ObjectMethod\") continue;\n          this.checkLVal(prop, bindingType, checkClashes, \"object destructuring pattern\", disallowLetBinding);\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {\n          const elem = _expr$elements[_i3];\n\n          if (elem) {\n            this.checkLVal(elem, bindingType, checkClashes, \"array destructuring pattern\", disallowLetBinding);\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, bindingType, checkClashes, \"assignment pattern\");\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, bindingType, checkClashes, \"rest element\");\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, bindingType, checkClashes, \"parenthesized expression\");\n        break;\n\n      default:\n        {\n          const message = (bindingType === BIND_NONE ? \"Invalid\" : \"Binding invalid\") + \" left-hand side\" + (contextDescription ? \" in \" + contextDescription : \"expression\");\n          this.raise(expr.start, message);\n        }\n    }\n  }\n\n  checkToRestConversion(node) {\n    if (node.argument.type !== \"Identifier\" && node.argument.type !== \"MemberExpression\") {\n      this.raise(node.argument.start, \"Invalid rest operator's argument\");\n    }\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.match(types.comma)) {\n      if (this.lookaheadCharCode() === close) {\n        this.raiseTrailingCommaAfterRest(this.state.start);\n      } else {\n        this.raiseRestNotLast(this.state.start);\n      }\n    }\n  }\n\n  raiseRestNotLast(pos) {\n    throw this.raise(pos, `Rest element must be last element`);\n  }\n\n  raiseTrailingCommaAfterRest(pos) {\n    this.raise(pos, `Unexpected trailing comma after rest element`);\n  }\n\n}\n\nclass ExpressionParser extends LValParser {\n  checkDuplicatedProto(prop, protoRef) {\n    if (prop.type === \"SpreadElement\" || prop.computed || prop.kind || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n    if (name === \"__proto__\") {\n      if (protoRef.used && !protoRef.start) {\n        protoRef.start = key.start;\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  getExpression() {\n    this.scope.enter(SCOPE_PROGRAM);\n    this.nextToken();\n    const expr = this.parseExpression();\n\n    if (!this.match(types.eof)) {\n      this.unexpected();\n    }\n\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    return expr;\n  }\n\n  parseExpression(noIn, refShorthandDefaultPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);\n\n    if (this.match(types.comma)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(types.comma)) {\n        node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));\n      }\n\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    if (this.isContextual(\"yield\")) {\n      if (this.scope.inGenerator) {\n        let left = this.parseYield(noIn);\n\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n\n        return left;\n      } else {\n        this.state.exprAllowed = false;\n      }\n    }\n\n    let failOnShorthandAssign;\n\n    if (refShorthandDefaultPos) {\n      failOnShorthandAssign = false;\n    } else {\n      refShorthandDefaultPos = {\n        start: 0\n      };\n      failOnShorthandAssign = true;\n    }\n\n    if (this.match(types.parenL) || this.match(types.name)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (this.state.type.isAssign) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (operator === \"??=\") {\n        this.expectPlugin(\"nullishCoalescingOperator\");\n        this.expectPlugin(\"logicalAssignment\");\n      }\n\n      if (operator === \"||=\" || operator === \"&&=\") {\n        this.expectPlugin(\"logicalAssignment\");\n      }\n\n      node.left = this.match(types.eq) ? this.toAssignable(left, undefined, \"assignment expression\") : left;\n\n      if (refShorthandDefaultPos.start >= node.left.start) {\n        refShorthandDefaultPos.start = 0;\n      }\n\n      this.checkLVal(left, undefined, undefined, \"assignment expression\");\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    return left;\n  }\n\n  parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(noIn, refShorthandDefaultPos);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n    return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n  }\n\n  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (this.eat(types.question)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprOps(noIn, refShorthandDefaultPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnary(refShorthandDefaultPos);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    const prec = this.state.type.binop;\n\n    if (prec != null && (!noIn || !this.match(types._in))) {\n      if (prec > minPrec) {\n        const operator = this.state.value;\n\n        if (operator === \"|>\" && this.state.inFSharpPipelineDirectBody) {\n          return left;\n        }\n\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = operator;\n\n        if (operator === \"**\" && left.type === \"UnaryExpression\" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {\n          this.raise(left.argument.start, \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\");\n        }\n\n        const op = this.state.type;\n\n        if (op === types.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          this.state.inPipeline = true;\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\n        } else if (op === types.nullishCoalescing) {\n          this.expectPlugin(\"nullishCoalescingOperator\");\n        }\n\n        this.next();\n\n        if (op === types.pipeline && this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\") {\n          if (this.match(types.name) && this.state.value === \"await\" && this.scope.inAsync) {\n            throw this.raise(this.state.start, `Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal`);\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec, noIn);\n\n        if (op === types.nullishCoalescing) {\n          if (left.type === \"LogicalExpression\" && left.operator !== \"??\" && !(left.extra && left.extra.parenthesized)) {\n            throw this.raise(left.start, `Nullish coalescing operator(??) requires parens when mixing with logical operators`);\n          } else if (node.right.type === \"LogicalExpression\" && node.right.operator !== \"??\" && !(node.right.extra && node.right.extra.parenthesized)) {\n            throw this.raise(node.right.start, `Nullish coalescing operator(??) requires parens when mixing with logical operators`);\n          }\n        }\n\n        this.finishNode(node, op === types.logicalOR || op === types.logicalAND || op === types.nullishCoalescing ? \"LogicalExpression\" : \"BinaryExpression\");\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n      }\n    }\n\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec, noIn) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    switch (op) {\n      case types.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"smart\":\n            return this.withTopicPermittingContext(() => {\n              return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc);\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec, noIn);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec, noIn);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec, noIn) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);\n  }\n\n  parseMaybeUnary(refShorthandDefaultPos) {\n    if (this.isContextual(\"await\") && this.isAwaitAllowed()) {\n      return this.parseAwait();\n    } else if (this.state.type.prefix) {\n      const node = this.startNode();\n      const update = this.match(types.incDec);\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (node.operator === \"throw\") {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      this.next();\n      node.argument = this.parseMaybeUnary();\n\n      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n        this.unexpected(refShorthandDefaultPos.start);\n      }\n\n      if (update) {\n        this.checkLVal(node.argument, undefined, undefined, \"prefix operation\");\n      } else if (this.state.strict && node.operator === \"delete\") {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(node.start, \"Deleting local variable in strict mode\");\n        } else if (arg.type === \"MemberExpression\" && arg.property.type === \"PrivateName\") {\n          this.raise(node.start, \"Deleting a private field is not allowed\");\n        }\n      }\n\n      return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refShorthandDefaultPos);\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.checkLVal(expr, undefined, undefined, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(node, \"UpdateExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprSubscripts(refShorthandDefaultPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refShorthandDefaultPos);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsync(base),\n      stop: false\n    };\n\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n\n    return base;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.callee = this.parseNoCallExpr();\n      state.stop = true;\n      return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n    } else if (this.match(types.questionDot)) {\n      this.expectPlugin(\"optionalChaining\");\n      state.optionalChainMember = true;\n\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n\n      if (this.eat(types.bracketL)) {\n        node.object = base;\n        node.property = this.parseExpression();\n        node.computed = true;\n        node.optional = true;\n        this.expect(types.bracketR);\n        return this.finishNode(node, \"OptionalMemberExpression\");\n      } else if (this.eat(types.parenL)) {\n        node.callee = base;\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, true);\n      } else {\n        node.object = base;\n        node.property = this.parseIdentifier(true);\n        node.computed = false;\n        node.optional = true;\n        return this.finishNode(node, \"OptionalMemberExpression\");\n      }\n    } else if (this.eat(types.dot)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = this.parseMaybePrivateName();\n      node.computed = false;\n\n      if (node.property.type === \"PrivateName\" && node.object.type === \"Super\") {\n        this.raise(startPos, \"Private fields can't be accessed on super\");\n      }\n\n      if (state.optionalChainMember) {\n        node.optional = false;\n        return this.finishNode(node, \"OptionalMemberExpression\");\n      }\n\n      return this.finishNode(node, \"MemberExpression\");\n    } else if (this.eat(types.bracketL)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = this.parseExpression();\n      node.computed = true;\n      this.expect(types.bracketR);\n\n      if (state.optionalChainMember) {\n        node.optional = false;\n        return this.finishNode(node, \"OptionalMemberExpression\");\n      }\n\n      return this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.match(types.parenL)) {\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n      const oldYieldPos = this.state.yieldPos;\n      const oldAwaitPos = this.state.awaitPos;\n      this.state.maybeInArrowParameters = true;\n      this.state.yieldPos = -1;\n      this.state.awaitPos = -1;\n      this.next();\n      let node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === \"Import\", base.type !== \"Super\", node);\n      this.finishCallExpression(node, state.optionalChainMember);\n\n      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow()) {\n        state.stop = true;\n        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);\n        this.checkYieldAwaitInDefaultParams();\n        this.state.yieldPos = oldYieldPos;\n        this.state.awaitPos = oldAwaitPos;\n      } else {\n        this.toReferencedListDeep(node.arguments);\n        if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;\n\n        if (!this.isAwaitAllowed() && !oldMaybeInArrowParameters || oldAwaitPos !== -1) {\n          this.state.awaitPos = oldAwaitPos;\n        }\n      }\n\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n      return node;\n    } else if (this.match(types.backQuote)) {\n      return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);\n    } else {\n      state.stop = true;\n      return base;\n    }\n  }\n\n  parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (typeArguments) node.typeParameters = typeArguments;\n\n    if (state.optionalChainMember) {\n      this.raise(startPos, \"Tagged Template Literals are not allowed in optionalChain\");\n    }\n\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsync(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n  }\n\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length !== 1) {\n        this.raise(node.start, \"import() requires exactly one argument\");\n      } else {\n        const importArg = node.arguments[0];\n\n        if (importArg && importArg.type === \"SpreadElement\") {\n          this.raise(importArg.start, \"... is not allowed in import()\");\n        }\n      }\n    }\n\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n\n  parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {\n    const elts = [];\n    let innerParenStart;\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (dynamicImport) {\n            this.raise(this.state.lastTokStart, \"Trailing comma is disallowed inside import(...) arguments\");\n          }\n\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      if (this.match(types.parenL) && !innerParenStart) {\n        innerParenStart = this.state.start;\n      }\n\n      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, allowPlaceholder));\n    }\n\n    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {\n      this.unexpected();\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  parseExprAtom(refShorthandDefaultPos) {\n    if (this.state.type === types.slash) this.readRegexp();\n    const canBeArrow = this.state.potentialArrowAt === this.state.start;\n    let node;\n\n    switch (this.state.type) {\n      case types._super:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n          this.raise(node.start, \"super() is only valid inside a class constructor of a subclass. \" + \"Maybe a typo in the method name ('constructor') or not extending another class?\");\n        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n          this.raise(node.start, \"super is only allowed in object methods and classes\");\n        }\n\n        if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n          this.raise(node.start, \"super can only be used with function calls (i.e. super()) or \" + \"in property accesses (i.e. super.prop or super[prop])\");\n        }\n\n        return this.finishNode(node, \"Super\");\n\n      case types._import:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(types.dot)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        this.expectPlugin(\"dynamicImport\", node.start);\n\n        if (!this.match(types.parenL)) {\n          this.unexpected(null, types.parenL);\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case types._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case types.name:\n        {\n          node = this.startNode();\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (!containsEsc && id.name === \"async\" && this.match(types._function) && !this.canInsertSemicolon()) {\n            const last = this.state.context.length - 1;\n\n            if (this.state.context[last] !== types$1.functionStatement) {\n              throw new Error(\"Internal error\");\n            }\n\n            this.state.context[last] = types$1.functionExpression;\n            this.next();\n            return this.parseFunction(node, undefined, true);\n          } else if (canBeArrow && !containsEsc && id.name === \"async\" && this.match(types.name) && !this.canInsertSemicolon()) {\n            const params = [this.parseIdentifier()];\n            this.expect(types.arrow);\n            this.parseArrowExpression(node, params, true);\n            return node;\n          }\n\n          if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {\n            this.next();\n            this.parseArrowExpression(node, [id], false);\n            return node;\n          }\n\n          return id;\n        }\n\n      case types._do:\n        {\n          this.expectPlugin(\"doExpressions\");\n          const node = this.startNode();\n          this.next();\n          const oldLabels = this.state.labels;\n          this.state.labels = [];\n          node.body = this.parseBlock();\n          this.state.labels = oldLabels;\n          return this.finishNode(node, \"DoExpression\");\n        }\n\n      case types.regexp:\n        {\n          const value = this.state.value;\n          node = this.parseLiteral(value.value, \"RegExpLiteral\");\n          node.pattern = value.pattern;\n          node.flags = value.flags;\n          return node;\n        }\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n      case types._null:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"NullLiteral\");\n\n      case types._true:\n      case types._false:\n        return this.parseBooleanLiteral();\n\n      case types.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case types.bracketL:\n        {\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          this.state.inFSharpPipelineDirectBody = false;\n          node = this.startNode();\n          this.next();\n          node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos, node);\n\n          if (!this.state.maybeInArrowParameters) {\n            this.toReferencedList(node.elements);\n          }\n\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return this.finishNode(node, \"ArrayExpression\");\n        }\n\n      case types.braceL:\n        {\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          this.state.inFSharpPipelineDirectBody = false;\n          const ret = this.parseObj(false, refShorthandDefaultPos);\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return ret;\n        }\n\n      case types._function:\n        return this.parseFunctionExpression();\n\n      case types.at:\n        this.parseDecorators();\n\n      case types._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case types._new:\n        return this.parseNew();\n\n      case types.backQuote:\n        return this.parseTemplate(false);\n\n      case types.doubleColon:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(callee.start, \"Binding should be performed on object property.\");\n          }\n        }\n\n      case types.hash:\n        {\n          if (this.state.inPipeline) {\n            node = this.startNode();\n\n            if (this.getPluginOption(\"pipelineOperator\", \"proposal\") !== \"smart\") {\n              this.raise(node.start, \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\");\n            }\n\n            this.next();\n\n            if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {\n              this.raise(node.start, `Topic reference was used in a lexical context without topic binding`);\n            }\n\n            this.registerTopicReference();\n            return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n          }\n        }\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseBooleanLiteral() {\n    const node = this.startNode();\n    node.value = this.match(types._true);\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseMaybePrivateName() {\n    const isPrivate = this.match(types.hash);\n\n    if (isPrivate) {\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space between # and identifier\");\n      node.id = this.parseIdentifier(true);\n      return this.finishNode(node, \"PrivateName\");\n    } else {\n      return this.parseIdentifier(true);\n    }\n  }\n\n  parseFunctionExpression() {\n    const node = this.startNode();\n    let meta = this.startNode();\n    this.next();\n    meta = this.createIdentifier(meta, \"function\");\n\n    if (this.scope.inGenerator && this.eat(types.dot)) {\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n\n    if (meta.name === \"function\" && propertyName === \"sent\") {\n      if (this.isContextual(propertyName)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n    }\n\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(node.property.start, `The only valid meta property for ${meta.name} is ${meta.name}.${propertyName}`);\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.expect(types.dot);\n\n    if (this.isContextual(\"meta\")) {\n      this.expectPlugin(\"importMeta\");\n\n      if (!this.inModule) {\n        this.raise(id.start, `import.meta may appear only with 'sourceType: \"module\"'`, {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        });\n      }\n\n      this.sawUnambiguousESM = true;\n    } else if (!this.hasPlugin(\"importMeta\")) {\n      this.raise(id.start, `Dynamic imports require a parameter: import('a.js')`);\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    const node = this.startNodeAt(startPos, startLoc);\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let val;\n    this.expect(types.parenL);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refShorthandDefaultPos = {\n      start: 0\n    };\n    const refNeedsArrowPos = {\n      start: 0\n    };\n    let first = true;\n    let spreadStart;\n    let optionalCommaStart;\n\n    while (!this.match(types.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma, refNeedsArrowPos.start || null);\n\n        if (this.match(types.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(types.ellipsis)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));\n        this.checkCommaAfterRest(41);\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));\n      }\n    }\n\n    const innerEndPos = this.state.start;\n    const innerEndLoc = this.state.startLoc;\n    this.expect(types.parenR);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkYieldAwaitInDefaultParams();\n      this.state.yieldPos = oldYieldPos;\n      this.state.awaitPos = oldAwaitPos;\n\n      for (let _i = 0; _i < exprList.length; _i++) {\n        const param = exprList[_i];\n\n        if (param.extra && param.extra.parenthesized) {\n          this.unexpected(param.extra.parenStart);\n        }\n      }\n\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n\n    if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;\n    if (oldAwaitPos !== -1) this.state.awaitPos = oldAwaitPos;\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n\n    if (refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n    this.toReferencedListDeep(exprList, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(val, \"parenthesized\", true);\n      this.addExtra(val, \"parenStart\", startPos);\n      return val;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = val;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  shouldParseArrow() {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node) {\n    if (this.eat(types.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    return node;\n  }\n\n  parseNew() {\n    const node = this.startNode();\n    let meta = this.startNode();\n    this.next();\n    meta = this.createIdentifier(meta, \"new\");\n\n    if (this.eat(types.dot)) {\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.state.inClassProperty) {\n        let error = \"new.target can only be used in functions\";\n\n        if (this.hasPlugin(\"classProperties\")) {\n          error += \" or class properties\";\n        }\n\n        this.raise(metaProp.start, error);\n      }\n\n      return metaProp;\n    }\n\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"Import\") {\n      this.raise(node.callee.start, \"Cannot use new with import(...)\");\n    } else if (node.callee.type === \"OptionalMemberExpression\" || node.callee.type === \"OptionalCallExpression\") {\n      this.raise(this.state.lastTokEnd, \"constructors in/after an Optional Chain are not allowed\");\n    } else if (this.eat(types.questionDot)) {\n      this.raise(this.state.start, \"constructors in/after an Optional Chain are not allowed\");\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewArguments(node) {\n    if (this.eat(types.parenL)) {\n      const args = this.parseExprList(types.parenR);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const elem = this.startNode();\n\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.invalidTemplateEscapePosition || 0, \"Invalid escape sequence in template\");\n      } else {\n        this.state.invalidTemplateEscapePosition = null;\n      }\n    }\n\n    elem.value = {\n      raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value\n    };\n    this.next();\n    elem.tail = this.match(types.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    this.next();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseObj(isPattern, refShorthandDefaultPos) {\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(types.braceR)) {\n          this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n          this.next();\n          break;\n        }\n      }\n\n      const prop = this.parseObjectMember(isPattern, refShorthandDefaultPos);\n      if (!isPattern) this.checkDuplicatedProto(prop, propHash);\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    if (!this.match(types.eq) && propHash.start !== undefined) {\n      this.raise(propHash.start, \"Redefinition of __proto__ property\");\n    }\n\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n  }\n\n  isAsyncProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.match(types.name) || this.match(types.num) || this.match(types.string) || this.match(types.bracketL) || this.state.type.keyword || this.match(types.star)) && !this.hasPrecedingLineBreak();\n  }\n\n  parseObjectMember(isPattern, refShorthandDefaultPos) {\n    let decorators = [];\n\n    if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(this.state.start, \"Stage 2 decorators disallow object literal property decorators\");\n      }\n\n      while (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isGenerator = false;\n    let isAsync = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(types.ellipsis)) {\n      if (decorators.length) this.unexpected();\n\n      if (isPattern) {\n        this.next();\n        prop.argument = this.parseIdentifier();\n        this.checkCommaAfterRest(125);\n        return this.finishNode(prop, \"RestElement\");\n      }\n\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (isPattern || refShorthandDefaultPos) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.parsePropertyName(prop);\n\n    if (!isPattern && !containsEsc && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.eat(types.star);\n      this.parsePropertyName(prop);\n    } else {\n      isAsync = false;\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);\n    return prop;\n  }\n\n  isGetterOrSetterMethod(prop, isPattern) {\n    return !isPattern && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  checkGetterSetterParams(method) {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const start = method.start;\n\n    if (method.params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, \"getter must not have any formal parameters\");\n      } else {\n        this.raise(start, \"setter must have exactly one formal parameter\");\n      }\n    }\n\n    if (method.kind === \"set\" && method.params[method.params.length - 1].type === \"RestElement\") {\n      this.raise(start, \"setter function argument must not be a rest parameter\");\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {\n    if (isAsync || isGenerator || this.match(types.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n\n    if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {\n      if (isGenerator || isAsync) this.unexpected();\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      this.parseMethod(prop, false, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {\n    prop.shorthand = false;\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.start, true, true);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else if (this.match(types.eq) && refShorthandDefaultPos) {\n        if (!refShorthandDefaultPos.start) {\n          refShorthandDefaultPos.start = this.state.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else {\n        prop.value = prop.key.__clone();\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n    } else {\n      const oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true;\n      prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseMaybePrivateName();\n\n      if (prop.key.type !== \"PrivateName\") {\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.parseFunctionParams(node, allowModifiers);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.scope.exit();\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n    return node;\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaPos) {\n    this.scope.enter(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    this.state.maybeInArrowParameters = false;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    if (params) this.setArrowFunctionParameters(node, params, trailingCommaPos);\n    this.parseFunctionBody(node, true);\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(node, params, trailingCommaPos) {\n    node.params = this.toAssignableList(params, true, \"arrow function parameters\", trailingCommaPos);\n  }\n\n  isStrictBody(node) {\n    const isBlockStatement = node.body.type === \"BlockStatement\";\n\n    if (isBlockStatement && node.body.directives.length) {\n      for (let _i2 = 0, _node$body$directives = node.body.directives; _i2 < _node$body$directives.length; _i2++) {\n        const directive = _node$body$directives[_i2];\n\n        if (directive.value.value === \"use strict\") {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(types.braceL);\n    const oldStrict = this.state.strict;\n    let useStrict = false;\n    const oldInParameters = this.state.inParameters;\n    this.state.inParameters = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const nonSimple = !this.isSimpleParamList(node.params);\n\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.state.end);\n\n        if (useStrict && nonSimple) {\n          const errorPos = (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.end : node.start;\n          this.raise(errorPos, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n        }\n      }\n\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      if (useStrict) this.state.strict = true;\n      this.checkParams(node, !oldStrict && !useStrict && !allowExpression && !isMethod && !nonSimple, allowExpression, !oldStrict && useStrict);\n      node.body = this.parseBlock(true, false);\n      this.state.labels = oldLabels;\n    }\n\n    this.state.inParameters = oldInParameters;\n\n    if (this.state.strict && node.id) {\n      this.checkLVal(node.id, BIND_OUTSIDE, undefined, \"function name\", undefined, !oldStrict && useStrict);\n    }\n\n    this.state.strict = oldStrict;\n  }\n\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (params[i].type !== \"Identifier\") return false;\n    }\n\n    return true;\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const nameHash = Object.create(null);\n\n    for (let i = 0; i < node.params.length; i++) {\n      this.checkLVal(node.params[i], BIND_VAR, allowDuplicates ? null : nameHash, \"function parameter list\", undefined, strictModeChanged);\n    }\n  }\n\n  parseExprList(close, allowEmpty, refShorthandDefaultPos, nodeForExtra) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));\n    }\n\n    return elts;\n  }\n\n  parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos, allowPlaceholder) {\n    let elt;\n\n    if (allowEmpty && this.match(types.comma)) {\n      elt = null;\n    } else if (this.match(types.ellipsis)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refShorthandDefaultPos, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);\n    } else if (this.match(types.question)) {\n      this.expectPlugin(\"partialApplication\");\n\n      if (!allowPlaceholder) {\n        this.raise(this.state.start, \"Unexpected argument placeholder\");\n      }\n\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);\n    }\n\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos, liberal) {\n    let name;\n\n    if (this.match(types.name)) {\n      name = this.state.value;\n    } else if (this.state.type.keyword) {\n      name = this.state.type.keyword;\n\n      if ((name === \"class\" || name === \"function\") && (this.state.lastTokEnd !== this.state.lastTokStart + 1 || this.input.charCodeAt(this.state.lastTokStart) !== 46)) {\n        this.state.context.pop();\n      }\n    } else {\n      throw this.unexpected();\n    }\n\n    if (liberal) {\n      this.state.type = types.name;\n    } else {\n      this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, false);\n    }\n\n    this.next();\n    return name;\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (this.scope.inGenerator && word === \"yield\") {\n      this.raise(startLoc, \"Can not use 'yield' as identifier inside a generator\");\n      return;\n    }\n\n    if (word === \"await\") {\n      if (this.scope.inAsync) {\n        this.raise(startLoc, \"Can not use 'await' as identifier inside an async function\");\n        return;\n      }\n\n      if (this.state.awaitPos === -1 && (this.state.maybeInArrowParameters || this.isAwaitAllowed())) {\n        this.state.awaitPos = this.state.start;\n      }\n    }\n\n    if (this.scope.inClass && !this.scope.inNonArrowFunction && word === \"arguments\") {\n      this.raise(startLoc, \"'arguments' is not allowed in class field initializer\");\n      return;\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(startLoc, `Unexpected keyword '${word}'`);\n      return;\n    }\n\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      if (!this.scope.inAsync && word === \"await\") {\n        this.raise(startLoc, \"Can not use keyword 'await' outside an async function\");\n      } else {\n        this.raise(startLoc, `Unexpected reserved word '${word}'`);\n      }\n    }\n  }\n\n  isAwaitAllowed() {\n    if (this.scope.inFunction) return this.scope.inAsync;\n    if (this.options.allowAwaitOutsideFunction) return true;\n    if (this.hasPlugin(\"topLevelAwait\")) return this.inModule;\n    return false;\n  }\n\n  parseAwait() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.state.inParameters) {\n      this.raise(node.start, \"await is not allowed in async function parameters\");\n    } else if (this.state.awaitPos === -1) {\n      this.state.awaitPos = node.start;\n    }\n\n    if (this.eat(types.star)) {\n      this.raise(node.start, \"await* has been removed from the async functions proposal. Use Promise.all() instead.\");\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin(\"v8intrinsic\") && this.match(types.modulo)) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary();\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  parseYield(noIn) {\n    const node = this.startNode();\n\n    if (this.state.inParameters) {\n      this.raise(node.start, \"yield is not allowed in generator parameters\");\n    } else if (this.state.yieldPos === -1) {\n      this.state.yieldPos = node.start;\n    }\n\n    this.next();\n\n    if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign(noIn);\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartPos) {\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(leftStartPos, `Pipeline head should not be a comma-separated sequence expression`);\n      }\n    }\n  }\n\n  parseSmartPipelineBody(childExpression, startPos, startLoc) {\n    const pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);\n    this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos);\n    return this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);\n  }\n\n  checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {\n    if (this.match(types.arrow)) {\n      throw this.raise(this.state.start, `Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized`);\n    } else if (pipelineStyle === \"PipelineTopicExpression\" && childExpression.type === \"SequenceExpression\") {\n      this.raise(startPos, `Pipeline body may not be a comma-separated sequence expression`);\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n\n    switch (pipelineStyle) {\n      case \"PipelineBareFunction\":\n        bodyNode.callee = childExpression;\n        break;\n\n      case \"PipelineBareConstructor\":\n        bodyNode.callee = childExpression.callee;\n        break;\n\n      case \"PipelineBareAwaitedFunction\":\n        bodyNode.callee = childExpression.argument;\n        break;\n\n      case \"PipelineTopicExpression\":\n        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {\n          this.raise(startPos, `Pipeline is in topic style but does not use topic reference`);\n        }\n\n        bodyNode.expression = childExpression;\n        break;\n\n      default:\n        throw new Error(`Internal @babel/parser error: Unknown pipeline style (${pipelineStyle})`);\n    }\n\n    return this.finishNode(bodyNode, pipelineStyle);\n  }\n\n  checkSmartPipelineBodyStyle(expression) {\n    switch (expression.type) {\n      default:\n        return this.isSimpleReference(expression) ? \"PipelineBareFunction\" : \"PipelineTopicExpression\";\n    }\n  }\n\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  withTopicPermittingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withTopicForbiddingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  primaryTopicReferenceIsAllowedInCurrentTopicContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentTopicContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n\n  parseFSharpPipelineBody(prec, noIn) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n}\n\nconst loopLabel = {\n  kind: \"loop\"\n},\n      switchLabel = {\n  kind: \"switch\"\n};\nconst FUNC_NO_FLAGS = 0b000,\n      FUNC_STATEMENT = 0b001,\n      FUNC_HANGING_STATEMENT = 0b010,\n      FUNC_NULLABLE_ID = 0b100;\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    program.sourceType = this.options.sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, types.eof);\n\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (let _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {\n        const [name] = _Array$from[_i];\n        const pos = this.scope.undefinedExports.get(name);\n        this.raise(pos, `Export '${name}' is not defined`);\n      }\n    }\n\n    file.program = this.finishNode(program, \"Program\");\n    file.comments = this.state.comments;\n    if (this.options.tokens) file.tokens = this.state.tokens;\n    return this.finishNode(file, \"File\");\n  }\n\n  stmtToDirective(stmt) {\n    const expr = stmt.expression;\n    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n    const directive = this.startNodeAt(stmt.start, stmt.loc.start);\n    const raw = this.input.slice(expr.start, expr.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n  }\n\n  parseInterpreterDirective() {\n    if (!this.match(types.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context) {\n    if (!this.isContextual(\"let\")) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const nextCh = this.input.charCodeAt(next);\n    if (nextCh === 91) return true;\n    if (context) return false;\n    if (nextCh === 123) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      let pos = next + 1;\n\n      while (isIdentifierChar(this.input.charCodeAt(pos))) {\n        ++pos;\n      }\n\n      const ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) return true;\n    }\n\n    return false;\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.match(types.at)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context, topLevel) {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case types._break:\n      case types._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case types._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case types._do:\n        return this.parseDoStatement(node);\n\n      case types._for:\n        return this.parseForStatement(node);\n\n      case types._function:\n        if (this.lookaheadCharCode() === 46) break;\n\n        if (context) {\n          if (this.state.strict) {\n            this.raise(this.state.start, \"In strict mode code, functions can only be declared at top level or inside a block\");\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(this.state.start, \"In non-strict mode code, functions can only be declared at top level, \" + \"inside a block, or as the body of an if statement\");\n          }\n        }\n\n        return this.parseFunctionStatement(node, false, !context);\n\n      case types._class:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case types._if:\n        return this.parseIfStatement(node);\n\n      case types._return:\n        return this.parseReturnStatement(node);\n\n      case types._switch:\n        return this.parseSwitchStatement(node);\n\n      case types._throw:\n        return this.parseThrowStatement(node);\n\n      case types._try:\n        return this.parseTryStatement(node);\n\n      case types.handle:\n        if (context !== \"try\") {\n          this.raise(this.state.start, \"Received handle clause without a precedent try\");\n        }\n\n        return this.parseHandleMatcher(node);\n\n      case types._const:\n      case types._var:\n        kind = kind || this.state.value;\n\n        if (context && kind !== \"var\") {\n          this.raise(this.state.start, \"Lexical declaration cannot appear in a single-statement context\");\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case types._while:\n        return this.parseWhileStatement(node);\n\n      case types._with:\n        return this.parseWithStatement(node);\n\n      case types.braceL:\n        return this.parseBlock();\n\n      case types.semi:\n        return this.parseEmptyStatement(node);\n\n      case types._export:\n      case types._import:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(this.state.start, \"'import' and 'export' may only appear at the top level\");\n          }\n\n          this.next();\n          let result;\n\n          if (starttype === types._import) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(this.state.start, \"Async functions can only be declared at the top level or inside a block\");\n            }\n\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(node.start, `'import' and 'export' may appear only with 'sourceType: \"module\"'`, {\n        code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n      });\n    }\n  }\n\n  takeDecorators(node) {\n    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator() {\n    return this.match(types._class);\n  }\n\n  parseDecorators(allowExport) {\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(types.at)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(types._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, \"Using the export keyword between a decorator and a class is not allowed. \" + \"Please use `export @dec class` instead.\");\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(this.state.start, \"Leading decorators must be attached to a class declaration\");\n    }\n  }\n\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      this.state.decoratorStack.push([]);\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr;\n\n      if (this.eat(types.parenL)) {\n        expr = this.parseExpression();\n        this.expect(types.parenR);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(types.dot)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(types.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(node, keyword) {\n    const isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, keyword);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n\n  verifyBreakContinue(node, keyword) {\n    const isBreak = keyword === \"break\";\n    let i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      this.raise(node.start, \"Unsyntactic \" + keyword);\n    }\n  }\n\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression() {\n    this.expect(types.parenL);\n    const val = this.parseExpression();\n    this.expect(types.parenR);\n    return val;\n  }\n\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(types.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = -1;\n\n    if (this.isAwaitAllowed() && this.eatContextual(\"await\")) {\n      awaitAt = this.state.lastTokStart;\n    }\n\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.parenL);\n\n    if (this.match(types.semi)) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    const isLet = this.isLet();\n\n    if (this.match(types._var) || this.match(types._const) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if ((this.match(types._in) || this.isContextual(\"of\")) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init);\n    }\n\n    const refShorthandDefaultPos = {\n      start: 0\n    };\n    const init = this.parseExpression(true, refShorthandDefaultPos);\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      const description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n      this.toAssignable(init, undefined, description);\n      this.checkLVal(init, undefined, undefined, description);\n      return this.parseForIn(node, init, awaitAt);\n    } else if (refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node) {\n    if (!this.scope.inFunction && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, \"'return' outside of function\");\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(types.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n\n    for (let sawDefault; !this.match(types.braceR);) {\n      if (this.match(types._case) || this.match(types._default)) {\n        const isCase = this.match(types._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(this.state.lastTokStart, \"Multiple default clauses\");\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(types.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node) {\n    this.next();\n\n    if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {\n      this.raise(this.state.lastTokEnd, \"Illegal newline after throw\");\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    const parseCatchHandleClause = () => {\n      const clause = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL)) {\n        this.expect(types.parenL);\n        clause.param = this.parseBindingAtom();\n        const simple = clause.param.type === \"Identifier\";\n        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLVal(clause.param, BIND_LEXICAL, null, \"catch clause\");\n        this.expect(types.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      return clause;\n    };\n\n    if (this.match(types._catch)) {\n      const clause = parseCatchHandleClause();\n      clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    } else if (this.match(types.handle)) {\n      this.parseHandleMatcher(node);\n    }\n\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, \"Missing catch or finally clause\");\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseHandleMatcher(node) {\n    this.next();\n\n    const parseHandleClause = () => {\n      const clause = this.startNode();\n      clause.effectMatcher = this.eat(types._default) ? null : this.parseExpression();\n      clause.defaultMatcher = !clause.effectMatcher;\n\n      if (!this.eat(types._with)) {\n        this.raise(node.start, \"Missing with Clause for Handler Statement\");\n      }\n\n      if (this.match(types.parenL)) {\n        this.expect(types.parenL);\n        clause.param = this.parseBindingAtom();\n        const simple = clause.param.type === \"Identifier\";\n        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLVal(clause.param, BIND_LEXICAL, null, \"catch clause\");\n        this.expect(types.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      return clause;\n    };\n\n    const clause = parseHandleClause();\n    clause.body = this.parseBlock(false, true);\n    clause.alternate = this.match(types.handle) ? this.parseStatement(\"try\") : null;\n    this.scope.exit();\n    node.handler = this.finishNode(clause, \"HandleClause\");\n    return node;\n  }\n\n  parseVarStatement(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(this.state.start, \"'with' in strict mode\");\n    }\n\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (let _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {\n      const label = _this$state$labels[_i2];\n\n      if (label.name === maybeName) {\n        this.raise(expr.start, `Label '${maybeName}' is already declared`);\n      }\n    }\n\n    const kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true) {\n    const node = this.startNode();\n    this.expect(types.braceL);\n\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n\n    this.parseBlockBody(node, allowDirectives, false, types.braceR);\n\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end) {\n    let parsedNonDirective = false;\n    let oldStrict;\n    let octalPosition;\n\n    while (!this.eat(end)) {\n      if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {\n        octalPosition = this.state.octalPosition;\n      }\n\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {\n        const directive = this.stmtToDirective(stmt);\n        directives.push(directive);\n\n        if (oldStrict === undefined && directive.value.value === \"use strict\") {\n          oldStrict = this.state.strict;\n          this.setStrict(true);\n\n          if (octalPosition) {\n            this.raise(octalPosition, \"Octal literal in strict mode\");\n          }\n        }\n\n        continue;\n      }\n\n      parsedNonDirective = true;\n      body.push(stmt);\n    }\n\n    if (oldStrict === false) {\n      this.setStrict(false);\n    }\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.match(types.semi) ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.match(types.parenR) ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(types._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt > -1) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt > -1;\n    }\n\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(init.start, `${isForIn ? \"for-in\" : \"for-of\"} loop variable declaration may not have an initializer`);\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, \"Invalid left-hand side in for-loop\");\n    }\n\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind) {\n    const declarations = node.declarations = [];\n    const isTypescript = this.hasPlugin(\"typescript\");\n    node.kind = kind;\n\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else {\n        if (kind === \"const\" && !(this.match(types._in) || this.isContextual(\"of\"))) {\n          if (!isTypescript) {\n            this.unexpected();\n          }\n        } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n          this.raise(this.state.lastTokEnd, \"Complex binding patterns require an initialization value\");\n        }\n\n        decl.init = null;\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) break;\n    }\n\n    return node;\n  }\n\n  parseVarId(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, undefined, \"variable declaration\", kind !== \"var\");\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n\n    if (this.match(types.star) && isHangingStatement) {\n      this.raise(this.state.start, \"Generators can only be declared at the top level or inside a block\");\n    }\n\n    node.generator = this.eat(types.star);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInClassProperty = this.state.inClassProperty;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    this.state.maybeInArrowParameters = false;\n    this.state.inClassProperty = false;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.scope.enter(functionFlags(node.async, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node);\n    this.withTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inClassProperty = oldInClassProperty;\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n    return node;\n  }\n\n  parseFunctionId(requireId) {\n    return requireId || this.match(types.name) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const oldInParameters = this.state.inParameters;\n    this.state.inParameters = true;\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);\n    this.state.inParameters = oldInParameters;\n    this.checkYieldAwaitInDefaultParams();\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass);\n    this.state.strict = oldStrict;\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n\n  isClassProperty() {\n    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n  }\n\n  isClassMethod() {\n    return this.match(types.parenL);\n  }\n\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n\n  parseClassBody(constructorAllowsSuper) {\n    this.state.classLevel++;\n    const state = {\n      hadConstructor: false\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(types.braceL);\n    this.withTopicForbiddingContext(() => {\n      while (!this.eat(types.braceR)) {\n        if (this.eat(types.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(this.state.lastTokEnd, \"Decorators must not be followed by a semicolon\");\n          }\n\n          continue;\n        }\n\n        if (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state, constructorAllowsSuper);\n\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(member.start, \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\");\n        }\n      }\n    });\n\n    if (decorators.length) {\n      throw this.raise(this.state.start, \"You have trailing decorators with no method\");\n    }\n\n    this.state.classLevel--;\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMember(classBody, member, state, constructorAllowsSuper) {\n    let isStatic = false;\n    const containsEsc = this.state.containsEsc;\n\n    if (this.match(types.name) && this.state.value === \"static\") {\n      const key = this.parseIdentifier(true);\n\n      if (this.isClassMethod()) {\n        const method = member;\n        method.kind = \"method\";\n        method.computed = false;\n        method.key = key;\n        method.static = false;\n        this.pushClassMethod(classBody, method, false, false, false, false);\n        return;\n      } else if (this.isClassProperty()) {\n        const prop = member;\n        prop.computed = false;\n        prop.key = key;\n        prop.static = false;\n        classBody.body.push(this.parseClassProperty(prop));\n        return;\n      } else if (containsEsc) {\n        throw this.unexpected();\n      }\n\n      isStatic = true;\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n\n    if (this.eat(types.star)) {\n      method.kind = \"method\";\n      this.parseClassPropertyName(method);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, \"Constructor can't be a generator\");\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parseClassPropertyName(member);\n    const isPrivate = key.type === \"PrivateName\";\n    const isSimple = key.type === \"Identifier\";\n    const maybeQuestionTokenStart = this.state.start;\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, \"Duplicate constructor in the same class\");\n        }\n\n        state.hadConstructor = true;\n        allowsDirectSuper = constructorAllowsSuper;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isSimple && key.name === \"async\" && !containsEsc && !this.isLineTerminator()) {\n      const isGenerator = this.eat(types.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStart);\n      }\n\n      method.kind = \"method\";\n      this.parseClassPropertyName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, \"Constructor can't be an async function\");\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isSimple && (key.name === \"get\" || key.name === \"set\") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {\n      method.kind = key.name;\n      this.parseClassPropertyName(publicMethod);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, \"Constructor can't have get/set modifier\");\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassPropertyName(member) {\n    const key = this.parsePropertyName(member);\n\n    if (!member.computed && member.static && (key.name === \"prototype\" || key.value === \"prototype\")) {\n      this.raise(key.start, \"Classes may not have static property named prototype\");\n    }\n\n    if (key.type === \"PrivateName\" && key.id.name === \"constructor\") {\n      this.raise(key.start, \"Classes may not have a private field named '#constructor'\");\n    }\n\n    return key;\n  }\n\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(prop.key.start, \"Classes may not have a field named 'constructor'\");\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(classBody, prop) {\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\n    classBody.body.push(this.parseClassPrivateProperty(prop));\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true));\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {}\n\n  parseAccessModifier() {\n    return undefined;\n  }\n\n  parseClassPrivateProperty(node) {\n    this.state.inClassProperty = true;\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;\n    this.semicolon();\n    this.state.inClassProperty = false;\n    this.scope.exit();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    if (!node.typeAnnotation) {\n      this.expectPlugin(\"classProperties\");\n    }\n\n    this.state.inClassProperty = true;\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n\n    if (this.match(types.eq)) {\n      this.expectPlugin(\"classProperties\");\n      this.next();\n      node.value = this.parseMaybeAssign();\n    } else {\n      node.value = null;\n    }\n\n    this.semicolon();\n    this.state.inClassProperty = false;\n    this.scope.exit();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (this.match(types.name)) {\n      node.id = this.parseIdentifier();\n\n      if (isStatement) {\n        this.checkLVal(node.id, bindingType, undefined, \"class name\");\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, \"A class name is required\");\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(types.comma);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, types.braceL);\n    }\n\n    let hasDeclaration;\n\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(types._default)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, types.braceL);\n  }\n\n  eatExportStar(node) {\n    return this.eat(types.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(\"as\")) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(types.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      node.specifiers.push(...this.parseExportSpecifiers());\n      node.source = null;\n      node.declaration = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      if (this.isContextual(\"async\")) {\n        const next = this.nextTokenStart();\n\n        if (!this.isUnparsedContextual(next, \"function\")) {\n          this.unexpected(next, `Unexpected token, expected \"function\"`);\n        }\n      }\n\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  isAsyncFunction() {\n    if (!this.isContextual(\"async\")) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(types._function) || isAsync) {\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    } else if (this.match(types._class)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, \"Decorators must be placed *before* the 'export' keyword.\" + \" You can set the 'decoratorsBeforeExport' option to false to use\" + \" the 'export @decorator class {}' syntax\");\n      }\n\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {\n      throw this.raise(this.state.start, \"Only expressions, functions or classes are allowed as the `default` export.\");\n    } else {\n      const res = this.parseMaybeAssign();\n      this.semicolon();\n      return res;\n    }\n  }\n\n  parseExportDeclaration(node) {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types.name)) {\n      return this.state.value !== \"async\" && this.state.value !== \"let\";\n    }\n\n    if (!this.match(types._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    return this.input.charCodeAt(next) === 44 || this.isUnparsedContextual(next, \"from\");\n  }\n\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(\"from\")) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.match(types.at)) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          this.unexpected(this.state.start, \"Decorators must be placed *before* the 'export' keyword.\" + \" You can set the 'decoratorsBeforeExport' option to false to use\" + \" the 'export @decorator class {}' syntax\");\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isLet() || this.isAsyncFunction();\n  }\n\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n      } else if (node.specifiers && node.specifiers.length) {\n        for (let _i3 = 0, _node$specifiers = node.specifiers; _i3 < _node$specifiers.length; _i3++) {\n          const specifier = _node$specifiers[_i3];\n          this.checkDuplicateExports(specifier, specifier.exported.name);\n\n          if (!isFrom && specifier.local) {\n            this.checkReservedWord(specifier.local.name, specifier.local.start, true, false);\n            this.scope.checkLocalExport(specifier.local);\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (let _i4 = 0, _node$declaration$dec = node.declaration.declarations; _i4 < _node$declaration$dec.length; _i4++) {\n            const declaration = _node$declaration$dec[_i4];\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      const isClass = node.declaration && (node.declaration.type === \"ClassDeclaration\" || node.declaration.type === \"ClassExpression\");\n\n      if (!node.declaration || !isClass) {\n        throw this.raise(node.start, \"You can only use decorators on an export when exporting a class\");\n      }\n\n      this.takeDecorators(node.declaration);\n    }\n  }\n\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (let _i5 = 0, _node$properties = node.properties; _i5 < _node$properties.length; _i5++) {\n        const prop = _node$properties[_i5];\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (let _i6 = 0, _node$elements = node.elements; _i6 < _node$elements.length; _i6++) {\n        const elem = _node$elements[_i6];\n\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(node, name) {\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n      this.raise(node.start, name === \"default\" ? \"Only one default export allowed per module.\" : `\\`${name}\\` has already been exported. Exported identifiers must be unique.`);\n    }\n\n    this.state.exportedIdentifiers.push(name);\n  }\n\n  parseExportSpecifiers() {\n    const nodes = [];\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      const node = this.startNode();\n      node.local = this.parseIdentifier(true);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdentifier(true) : node.local.__clone();\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n\n    if (!this.match(types.string)) {\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(types.comma);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(\"from\");\n    }\n\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    if (!this.match(types.string)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return this.match(types.name);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(types.star)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(types.colon)) {\n          throw this.raise(this.state.start, \"ES2015 named imports do not destructure. \" + \"Use another statement for destructuring after the import.\");\n        }\n\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    specifier.imported = this.parseIdentifier(true);\n\n    if (this.eatContextual(\"as\")) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      this.checkReservedWord(specifier.imported.name, specifier.start, true, true);\n      specifier.local = specifier.imported.__clone();\n    }\n\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, \"import specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n}\n\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    const ScopeHandler = this.getScopeHandler();\n    this.options = options;\n    this.inModule = this.options.sourceType === \"module\";\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n\n  parse() {\n    this.scope.enter(SCOPE_PROGRAM);\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n\n}\n\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n\n  for (let _i = 0; _i < plugins.length; _i++) {\n    const plugin = plugins[_i];\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  if (options && options.sourceType === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\n\nfunction getParser(options, input) {\n  let cls = Parser;\n\n  if (options && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (let _i = 0; _i < pluginList.length; _i++) {\n      const plugin = pluginList[_i];\n      cls = mixinPlugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_generator_visitor_1 = require(\"./to-generator-visitor\");\nexports.hasEffectsDirective = function (path) {\n    var directives = path.get(\"body.directives\");\n    if (!Array.isArray(directives))\n        return;\n    return directives === null || directives === void 0 ? void 0 : directives.map(function (directive) {\n        var _a;\n        return (_a = directive.get(\"value.value\")) === null || _a === void 0 ? void 0 : _a.node;\n    }).includes(\"use effects\");\n};\nexports.arrowExpressionToGenerator = function (types, path) {\n    // TODO: [major] - More care needs to be taken here:\n    //  We can't just convert the arrow function over to a generator. We need to perserve the current \"this\"\n    //  into \"self\" and pass it in.\n    return types.functionExpression(undefined, path.node.params, path.node.body, true, path.node.async);\n};\n// Starting from a child path, find the parent function and convert it to a generator.\n// Because we cannot predict what the value of call expressions will be, we must yield them to the stack interpreter.\nexports.fixupParentGenerator = function (path, types) {\n    var _a, _b, _c, _d, _e, _f;\n    var parentFunctionPath = path.findParent(function (x) {\n        return x.isFunction();\n    });\n    if (!parentFunctionPath) {\n        // TODO: Think about what needs to be done here... Can we safely just return?\n        return;\n    }\n    if (exports.hasEffectsDirective(parentFunctionPath))\n        return;\n    if (!((_a = parentFunctionPath === null || parentFunctionPath === void 0 ? void 0 : parentFunctionPath.node) === null || _a === void 0 ? void 0 : _a.generator)) {\n        if (types.isArrowFunctionExpression(parentFunctionPath.node)) {\n            parentFunctionPath.replaceWith(exports.arrowExpressionToGenerator(types, parentFunctionPath));\n        }\n        else {\n            parentFunctionPath.node.generator = true;\n        }\n        // Yield all internal call expressions\n        (_b = parentFunctionPath\n            .get(\"body\")) === null || _b === void 0 ? void 0 : _b.traverse(to_generator_visitor_1.yieldCallExpressionVisitor, { types: types });\n        var name_1 = types.isFunctionDeclaration(parentFunctionPath.node)\n            ? (_c = parentFunctionPath.node.id) === null || _c === void 0 ? void 0 : _c.name : (_e = (_d = parentFunctionPath.parentPath.node) === null || _d === void 0 ? void 0 : _d.id) === null || _e === void 0 ? void 0 : _e.name;\n        if (name_1) {\n            var bindingScope = parentFunctionPath.findParent(function (x) {\n                return x.scope.hasBinding(name_1);\n            });\n            (_f = bindingScope.scope\n                .getBinding(name_1)) === null || _f === void 0 ? void 0 : _f.referencePaths.forEach(function (reference) {\n                var expStatementParent = reference.findParent(types.isExpressionStatement) ||\n                    reference.parentPath;\n                if (!expStatementParent)\n                    return;\n                var isYield = types.isYieldExpression(expStatementParent.get(\"expression\"));\n                if (!isYield) {\n                    var callExpression = reference.findParent(types.isCallExpression);\n                    callExpression === null || callExpression === void 0 ? void 0 : callExpression.replaceWith(types.yieldExpression(callExpression.node));\n                }\n            });\n        }\n    }\n};\nexports.toMemberExpressionVisitor = {\n    Identifier: function (path, _a) {\n        var objectIdentifierName = _a.objectIdentifierName, propName = _a.propName, types = _a.types;\n        if (path.node.name === propName) {\n            path.replaceWith(types.memberExpression(types.identifier(objectIdentifierName), path.node));\n            path.skip();\n        }\n    }\n};\nexports.renameIdentNameVisitor = {\n    Identifier: function (path, _a) {\n        var newName = _a.newName, oldName = _a.oldName;\n        if (path.node.name === oldName) {\n            path.node.name = newName;\n        }\n    }\n};\n// Convert a destructured default into\n// object.prop = typeof object.prop !== 'undefined' ? object.prop : 'default'\n// TODO: Double check the spec to make sure this is BTB (by the books).\nexports.createDefaultAssignment = function (objectIdent, objectProp, types) {\n    if (types.isRestElement(objectProp) ||\n        !types.isAssignmentPattern(objectProp.value)) {\n        throw new Error(\"[Babel Plugin Effects Error]\");\n    }\n    return types.expressionStatement(types.assignmentExpression(\"=\", types.memberExpression(objectIdent, objectProp.key), types.conditionalExpression(types.binaryExpression(\"!==\", types.unaryExpression(\"typeof\", types.memberExpression(objectIdent, objectProp.key), true), types.stringLiteral(\"undefined\")), types.memberExpression(objectIdent, objectProp.key), objectProp.value.right)));\n};\nexports.collapseObjectPattern = function (handlerParam, types, handlerBodyPath) {\n    var identifierName = \"__e__\";\n    var defaultAssignments = [];\n    var objectIdentifier = types.identifier(identifierName);\n    for (var _i = 0, _a = handlerParam.properties; _i < _a.length; _i++) {\n        var property = _a[_i];\n        if (!types.isRestElement(property) &&\n            types.isAssignmentPattern(property.value)) {\n            defaultAssignments.push(exports.createDefaultAssignment(objectIdentifier, property, types));\n        }\n        if (types.isRestElement(property)) {\n            handlerBodyPath.traverse(exports.renameIdentNameVisitor, {\n                newName: identifierName,\n                oldName: property.argument.name\n            });\n        }\n        else {\n            handlerBodyPath.traverse(exports.toMemberExpressionVisitor, {\n                objectIdentifierName: objectIdentifier.name,\n                propName: property.key.name,\n                types: types\n            });\n        }\n    }\n    return { identifier: objectIdentifier, defaultAssignments: defaultAssignments };\n};\n//# sourceMappingURL=traverse-utilities.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_generator_visitor_1 = require(\"./to-generator-visitor\");\nfunction createRuntimeRoot(types, continuation) {\n    var mainFunctionExpression = types.functionExpression(null, [], types.blockStatement(continuation), true);\n    return types.callExpression(types.identifier(\"runProgram\"), [\n        types.callExpression(mainFunctionExpression, [])\n    ]);\n}\nvar runProgramYieldCallExpressionVisitor = {\n    Identifier: function (idPath, _a) {\n        var types = _a.types;\n        var _b, _c;\n        if (idPath.node.name === \"runProgram\") {\n            (_c = (_b = idPath\n                .findParent(types.isCallExpression)) === null || _b === void 0 ? void 0 : _b.get(\"arguments\")) === null || _c === void 0 ? void 0 : _c.forEach(function (n) {\n                n.traverse(to_generator_visitor_1.yieldCallExpressionVisitor, {\n                    types: types,\n                    skipChildTraversal: true\n                });\n            });\n        }\n    }\n};\nexports.effectsDirectiveVisitor = {\n    ExpressionStatement: function (path, _a) {\n        var types = _a.types;\n        var _b, _c;\n        var expression = (_b = path.get(\"expression\")) === null || _b === void 0 ? void 0 : _b.node;\n        var parentFunction = path.findParent(types.isFunction);\n        if (types.isStringLiteral(expression) &&\n            expression.value === \"use effects\") {\n            if (!Array.isArray(path.container)) {\n                throw new Error(\"[ Transform Effects Plugin Error ] - Encountered an unexpected state in the AST: 'Use Effects' directive found, but no continuation can be derived\");\n            }\n            var continuationStartKey = Number(path.key) + 1;\n            var continuation = path.container.slice(continuationStartKey);\n            // Hacky :(\n            for (var i = continuationStartKey; i < path.container.length; i += 1) {\n                (_c = path.getSibling(i)) === null || _c === void 0 ? void 0 : _c.remove();\n            }\n            var runtimeExpression = (parentFunction === null || parentFunction === void 0 ? void 0 : parentFunction.node.async) ? types.awaitExpression(createRuntimeRoot(types, continuation))\n                : createRuntimeRoot(types, continuation);\n            path.replaceWith(runtimeExpression);\n            path.traverse(runProgramYieldCallExpressionVisitor, { types: types });\n        }\n    },\n    Directive: function (path, _a) {\n        var types = _a.types;\n        var value = path.get(\"value.value\")\n            .node;\n        if (value !== \"use effects\")\n            return;\n        var blockParent = path.findParent(types.isBlockStatement);\n        if (!blockParent || !types.isBlockStatement(blockParent)) {\n            throw new Error(\"[ Transform Effects Plugin Error ] - Encountered an unexpected state in the AST: 'Use Effects' directive found, but no continuation can be derived\");\n        }\n        blockParent.node.body = [\n            types.returnStatement(createRuntimeRoot(types, blockParent.node.body))\n        ];\n        blockParent.traverse(runProgramYieldCallExpressionVisitor, { types: types });\n        path.remove();\n    }\n};\n//# sourceMappingURL=effects-directive-visitor.js.map","var $export = require('./_export');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar fromCharCode = String.fromCharCode;\nvar $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars\n    var res = [];\n    var aLen = arguments.length;\n    var i = 0;\n    var code;\n    while (aLen > i) {\n      code = +arguments[i++];\n      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar traverse_utilities_1 = require(\"./traverse-utilities\");\nvar perform_visitor_1 = require(\"./perform-visitor\");\nvar effects_common_1 = require(\"effects-common\");\nvar exists = effects_common_1.util.exists;\nexports.toGeneratorVisitor = {\n    Function: function (path, _a) {\n        var types = _a.types;\n        if (path.node.async)\n            return;\n        if (types.isArrowFunctionExpression(path.node)) {\n            path.replaceWith(traverse_utilities_1.arrowExpressionToGenerator(types, path));\n        }\n        else if (!path.node.generator) {\n            path.node.generator = true;\n        }\n        var body = path.get(\"body\");\n        body === null || body === void 0 ? void 0 : body.traverse(exports.yieldCallExpressionVisitor, { types: types });\n        body === null || body === void 0 ? void 0 : body.traverse(exports.callExpressionVisitor, { types: types });\n        body === null || body === void 0 ? void 0 : body.traverse(perform_visitor_1.performVisitor, { types: types });\n    }\n};\nexports.callExpressionVisitor = {\n    CallExpression: function (path, _a) {\n        var types = _a.types;\n        var parentFunction = path.findParent(types.isFunction);\n        var immediateParent = path.parent;\n        if ((parentFunction === null || parentFunction === void 0 ? void 0 : parentFunction.node.generator) &&\n            (types.isExpressionStatement(immediateParent) ||\n                types.isVariableDeclarator(immediateParent))) {\n            var callee = path.get(\"callee.name\").node;\n            var binding = path.scope.getBinding(callee);\n            if (binding && types.isFunctionDeclaration(binding.path.node)) {\n                binding.path.node.generator = true;\n            }\n            else {\n                binding === null || binding === void 0 ? void 0 : binding.path.traverse(exports.toGeneratorVisitor, { types: types });\n            }\n            if (!types.isYieldExpression(path.node)) {\n                path.replaceWith(types.yieldExpression(path.node));\n            }\n        }\n    }\n};\nexports.yieldCallExpressionVisitor = {\n    CallExpression: function (path, _a) {\n        var types = _a.types, skipChildTraversal = _a.skipChildTraversal;\n        var immediateParent = path.parent;\n        if (types.isYieldExpression(immediateParent))\n            return;\n        path.replaceWith(types.yieldExpression(path.node));\n        // Safety First\n        traverse_utilities_1.fixupParentGenerator(path, types);\n        if (exists(skipChildTraversal) && Boolean(skipChildTraversal)) {\n            path.skip();\n        }\n    }\n};\n//# sourceMappingURL=to-generator-visitor.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Visit recall statements and convert them to an interpreted stack frame call.\n */\nexports.recallVisitor = {\n    UnaryExpression: function (path, _a) {\n        var types = _a.types;\n        var _b;\n        // @ts-ignore\n        if (path.node.operator === \"recall\") {\n            var stackResumeExpression = types.callExpression(types.identifier(\"stackResume\"), [types.identifier(\"handler\"), path.node.argument]);\n            var thenExpression = types.callExpression(types.memberExpression(stackResumeExpression, types.identifier(\"then\")), [types.identifier(\"res\")]);\n            var catchExpression = types.callExpression(types.memberExpression(thenExpression, types.identifier(\"catch\")), [types.identifier(\"rej\")]);\n            path.replaceWith(catchExpression);\n            (_b = path\n                .findParent(types.isExpressionStatement)) === null || _b === void 0 ? void 0 : _b.replaceWith(types.returnStatement(path.node));\n        }\n    }\n};\n//# sourceMappingURL=recall-visitor.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar effects_directive_visitor_1 = require(\"./effects-directive-visitor\");\nvar handler_method_visitor_1 = require(\"./handler-method-visitor\");\nvar traverse_utilities_1 = require(\"./traverse-utilities\");\nvar parser = require(\"../../../babel/packages/babel-parser/lib\");\nfunction createHandler(types, path) {\n    var handlerObject = types.objectExpression([]);\n    handler_method_visitor_1.followHandlerDefinitions(path, handlerObject, types);\n    return handlerObject;\n}\n// This is performs the final inversion:\n// Transform a try-statement path and a handler into a `runProgram` call\n// TODO [major] - Capture errors into a continuation,\n// TODO [major] - Extend grammar to include a final catch clause, which will receive errors into the continuation.\nvar createWithHandlerInvocation = function (types, path, handler) {\n    var mainFunctionExpression = types.functionExpression(null, [], path.node.block, true, true);\n    return types.callExpression(types.identifier(\"withHandler\"), [\n        handler,\n        types.callExpression(mainFunctionExpression, [])\n    ]);\n};\nfunction transformEffects(_a) {\n    var types = _a.types;\n    return {\n        // Deliver the custom grammar parser to the top-level visitor\n        parserOverride: function (code, opts) {\n            return parser.parse(code, opts);\n        },\n        visitor: {\n            Program: {\n                exit: function (path) {\n                    path.traverse(effects_directive_visitor_1.effectsDirectiveVisitor, { types: types });\n                    path.traverse({\n                        YieldExpression: function (path) {\n                            traverse_utilities_1.fixupParentGenerator(path, types);\n                        }\n                    }, { types: types });\n                }\n            },\n            TryStatement: {\n                enter: function (path) {\n                    var _a, _b;\n                    var handlerBody = path.get(\"handler.body\");\n                    var handlerType = (_a = path.node.handler) === null || _a === void 0 ? void 0 : _a.type;\n                    // @ts-ignore\n                    if (handlerType !== \"HandleClause\" || !handlerBody)\n                        return;\n                    var handler = createHandler(types, path.get(\"handler\"));\n                    var withHandlerExpression = createWithHandlerInvocation(types, path, handler);\n                    traverse_utilities_1.fixupParentGenerator(path, types);\n                    var parent = path.findParent(types.isFunction);\n                    if ((_b = parent === null || parent === void 0 ? void 0 : parent.node) === null || _b === void 0 ? void 0 : _b.generator) {\n                        path.replaceWith(types.returnStatement(types.yieldExpression(withHandlerExpression)));\n                    }\n                    else {\n                        path.replaceWith(withHandlerExpression);\n                    }\n                }\n            },\n            UnaryExpression: function (path) {\n                var _a;\n                // TODO [minor] ignore required because types do not recognize the operator as valid. Fix that.\n                // @ts-ignore\n                if (path.node.operator === \"perform\") {\n                    path.replaceWith(types.yieldExpression(types.callExpression(types.identifier(\"performEffect\"), [\n                        path.node.argument\n                    ])));\n                    traverse_utilities_1.fixupParentGenerator(path, types);\n                }\n                // @ts-ignore\n                if (path.node.operator === \"recall\") {\n                    var stackResumeExpression = types.callExpression(types.identifier(\"stackResume\"), [types.identifier(\"handler\"), path.node.argument]);\n                    var thenExpression = types.callExpression(types.memberExpression(stackResumeExpression, types.identifier(\"then\")), [types.identifier(\"res\")]);\n                    var catchExpression = types.callExpression(types.memberExpression(thenExpression, types.identifier(\"catch\")), [types.identifier(\"rej\")]);\n                    path.replaceWith(catchExpression);\n                    (_a = path\n                        .findParent(types.isExpressionStatement)) === null || _a === void 0 ? void 0 : _a.replaceWith(types.returnStatement(path.node));\n                }\n            }\n        }\n    };\n}\nexports.default = transformEffects;\n//# sourceMappingURL=plugin.js.map","\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar traverse_utilities_1 = require(\"./traverse-utilities\");\nvar recall_visitor_1 = require(\"./recall-visitor\");\nvar isLiteralProp = function (node, types) {\n    return types.isLiteral(node) &&\n        !types.isNullLiteral(node) &&\n        !types.isRegExpLiteral(node) &&\n        !types.isTemplateLiteral(node);\n};\nvar extractMemberPropertyPathName = function (parentPath, types, memberPropertyNode) {\n    if (isLiteralProp(memberPropertyNode, types)) {\n        return {\n            ident: types.identifier(memberPropertyNode.value),\n            isComputed: false\n        };\n    }\n    else if (types.isIdentifier(memberPropertyNode)) {\n        var binding = parentPath.scope.getBinding(memberPropertyNode.name);\n        if (binding && types.isIdentifier(memberPropertyNode)) {\n            return { ident: memberPropertyNode, isComputed: true };\n        }\n    }\n    else if (parentPath.get(\"defaultMatcher\").node) {\n        return {\n            ident: types.identifier(\"__defaultEffectHandler__\"),\n            isComputed: true\n        };\n    }\n    throw new Error(\"[Babel Effects Transform Error] - Failed to construct handler. Could not find a valid definition for handler name\");\n};\nvar makeHandlerMethod = function (memberPropertyPath, rootPath, types, consequent, handlerParamName, defaultAssignments) {\n    var _a = extractMemberPropertyPathName(rootPath, types, memberPropertyPath.node), handlerPropertyName = _a.ident, isComputed = _a.isComputed;\n    // Collect all call expressions located inside of the handler (consequent block)\n    var callExpressionDeclarations = [];\n    consequent.traverse({\n        CallExpression: function (expressionPath) {\n            var binding = expressionPath.scope.getBinding(expressionPath.node.callee.name);\n            var declaration = binding === null || binding === void 0 ? void 0 : binding.path.find(function (x) { return types.isVariableDeclaration(x) || types.isFunctionDeclaration(x); });\n            if (declaration) {\n                callExpressionDeclarations.push(declaration.node);\n                declaration.remove();\n            }\n        }\n    });\n    var consequentBody = types.isBlockStatement(consequent.node)\n        ? consequent.node.body\n        : types.blockStatement([consequent.node]).body;\n    // GEE WHIZ!\n    var resultContinuation = types.variableDeclaration(\"const\", [\n        types.variableDeclarator(types.identifier(\"result\"), types.yieldExpression(types.functionExpression(null, [types.identifier(\"handler\")], types.blockStatement([\n            types.returnStatement(types.newExpression(types.identifier(\"Promise\"), [\n                types.arrowFunctionExpression([types.identifier(\"res\"), types.identifier(\"rej\")], types.blockStatement([\n                    types.tryStatement(types.blockStatement(__spreadArrays(callExpressionDeclarations, defaultAssignments, consequentBody)), types.catchClause(types.identifier(\"handlerError\"), types.blockStatement([\n                        types.expressionStatement(types.callExpression(types.identifier(\"rej\"), [\n                            types.identifier(\"handlerError\")\n                        ]))\n                    ])), null)\n                ]), true)\n            ]))\n        ]))))\n    ]);\n    var objectMethod = types.objectMethod(\"method\", handlerPropertyName ? handlerPropertyName : memberPropertyPath.node, [types.identifier(\"\" + handlerParamName), types.identifier(\"resume\")], types.blockStatement([\n        resultContinuation,\n        types.returnStatement(types.yieldExpression(types.callExpression(types.identifier(\"resume\"), [\n            types.identifier(\"result\")\n        ])))\n    ]), isComputed);\n    objectMethod.generator = true;\n    return objectMethod;\n};\n// Annoying:\n// For now, cannot traverse the HandlerClause node like it was a normal AST node\n// without further customization of the babel fork.\nexports.followHandlerDefinitions = function (handlerPath, handlerObject, types) {\n    var handlerBody = handlerPath.get(\"body\");\n    var handlerParam = handlerPath.get(\"param\").node;\n    var oldIdentName = types.isIdentifier(handlerParam)\n        ? handlerParam.name\n        : null;\n    var newIdentName = types.isIdentifier(handlerParam)\n        ? \"__\" + handlerParam.name + \"__\"\n        : null;\n    var _a = types.isObjectPattern(handlerParam)\n        ? traverse_utilities_1.collapseObjectPattern(handlerParam, types, handlerBody)\n        : {\n            identifier: types.identifier(newIdentName),\n            defaultAssignments: []\n        }, identifier = _a.identifier, defaultAssignments = _a.defaultAssignments;\n    if (oldIdentName) {\n        handlerBody.traverse(traverse_utilities_1.renameIdentNameVisitor, {\n            newName: newIdentName,\n            oldName: oldIdentName\n        });\n    }\n    handlerBody.traverse(recall_visitor_1.recallVisitor, { types: types });\n    handlerObject.properties.push(makeHandlerMethod(handlerPath.get(\"effectMatcher\"), handlerPath, types, handlerPath.get(\"body\"), identifier.name, defaultAssignments));\n    var alternatePath = handlerPath.node.alternate\n        ? handlerPath.get(\"alternate.handler\")\n        : null;\n    if (alternatePath)\n        exports.followHandlerDefinitions(alternatePath, handlerObject, types);\n};\n//# sourceMappingURL=handler-method-visitor.js.map","'use strict';\nvar $export = require('./_export');\nvar $at = require('./_string-at')(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos) {\n    return $at(this, pos);\n  }\n});\n"],"sourceRoot":""}